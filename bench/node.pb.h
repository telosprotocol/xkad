// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node.proto

#ifndef PROTOBUF_INCLUDED_node_2eproto
#define PROTOBUF_INCLUDED_node_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_node_2eproto 

namespace protobuf_node_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_node_2eproto
namespace top {
namespace kadmlia {
namespace test {
namespace pb {
class AllNodes;
class AllNodesDefaultTypeInternal;
extern AllNodesDefaultTypeInternal _AllNodes_default_instance_;
class AllNodes_Node;
class AllNodes_NodeDefaultTypeInternal;
extern AllNodes_NodeDefaultTypeInternal _AllNodes_Node_default_instance_;
class TestConn2Request;
class TestConn2RequestDefaultTypeInternal;
extern TestConn2RequestDefaultTypeInternal _TestConn2Request_default_instance_;
class TestConn2Response;
class TestConn2ResponseDefaultTypeInternal;
extern TestConn2ResponseDefaultTypeInternal _TestConn2Response_default_instance_;
class TestConnRequest;
class TestConnRequestDefaultTypeInternal;
extern TestConnRequestDefaultTypeInternal _TestConnRequest_default_instance_;
class TestConnResponse;
class TestConnResponseDefaultTypeInternal;
extern TestConnResponseDefaultTypeInternal _TestConnResponse_default_instance_;
class TestReportNodes;
class TestReportNodesDefaultTypeInternal;
extern TestReportNodesDefaultTypeInternal _TestReportNodes_default_instance_;
}  // namespace pb
}  // namespace test
}  // namespace kadmlia
}  // namespace top
namespace google {
namespace protobuf {
template<> ::top::kadmlia::test::pb::AllNodes* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::AllNodes>(Arena*);
template<> ::top::kadmlia::test::pb::AllNodes_Node* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::AllNodes_Node>(Arena*);
template<> ::top::kadmlia::test::pb::TestConn2Request* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::TestConn2Request>(Arena*);
template<> ::top::kadmlia::test::pb::TestConn2Response* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::TestConn2Response>(Arena*);
template<> ::top::kadmlia::test::pb::TestConnRequest* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::TestConnRequest>(Arena*);
template<> ::top::kadmlia::test::pb::TestConnResponse* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::TestConnResponse>(Arena*);
template<> ::top::kadmlia::test::pb::TestReportNodes* Arena::CreateMaybeMessage<::top::kadmlia::test::pb::TestReportNodes>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace top {
namespace kadmlia {
namespace test {
namespace pb {

// ===================================================================

class AllNodes_Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.AllNodes.Node) */ {
 public:
  AllNodes_Node();
  virtual ~AllNodes_Node();

  AllNodes_Node(const AllNodes_Node& from);

  inline AllNodes_Node& operator=(const AllNodes_Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllNodes_Node(AllNodes_Node&& from) noexcept
    : AllNodes_Node() {
    *this = ::std::move(from);
  }

  inline AllNodes_Node& operator=(AllNodes_Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllNodes_Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllNodes_Node* internal_default_instance() {
    return reinterpret_cast<const AllNodes_Node*>(
               &_AllNodes_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AllNodes_Node* other);
  friend void swap(AllNodes_Node& a, AllNodes_Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllNodes_Node* New() const final {
    return CreateMaybeMessage<AllNodes_Node>(NULL);
  }

  AllNodes_Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllNodes_Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AllNodes_Node& from);
  void MergeFrom(const AllNodes_Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllNodes_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const char* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // required string public_ip = 3;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 3;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const char* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // required bytes node_id = 10;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 10;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // required int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // required int32 public_port = 4;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 4;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // required uint64 service_type = 5;
  bool has_service_type() const;
  void clear_service_type();
  static const int kServiceTypeFieldNumber = 5;
  ::google::protobuf::uint64 service_type() const;
  void set_service_type(::google::protobuf::uint64 value);

  // required int32 nat_type = 6;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 6;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.AllNodes.Node)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_service_type();
  void clear_has_service_type();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_node_id();
  void clear_has_node_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::uint64 service_type_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AllNodes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.AllNodes) */ {
 public:
  AllNodes();
  virtual ~AllNodes();

  AllNodes(const AllNodes& from);

  inline AllNodes& operator=(const AllNodes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllNodes(AllNodes&& from) noexcept
    : AllNodes() {
    *this = ::std::move(from);
  }

  inline AllNodes& operator=(AllNodes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllNodes* internal_default_instance() {
    return reinterpret_cast<const AllNodes*>(
               &_AllNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AllNodes* other);
  friend void swap(AllNodes& a, AllNodes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllNodes* New() const final {
    return CreateMaybeMessage<AllNodes>(NULL);
  }

  AllNodes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllNodes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AllNodes& from);
  void MergeFrom(const AllNodes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllNodes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AllNodes_Node Node;

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.test.pb.AllNodes.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::test::pb::AllNodes_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::test::pb::AllNodes_Node >*
      mutable_nodes();
  const ::top::kadmlia::test::pb::AllNodes_Node& nodes(int index) const;
  ::top::kadmlia::test::pb::AllNodes_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::test::pb::AllNodes_Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.AllNodes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::test::pb::AllNodes_Node > nodes_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestReportNodes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.TestReportNodes) */ {
 public:
  TestReportNodes();
  virtual ~TestReportNodes();

  TestReportNodes(const TestReportNodes& from);

  inline TestReportNodes& operator=(const TestReportNodes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestReportNodes(TestReportNodes&& from) noexcept
    : TestReportNodes() {
    *this = ::std::move(from);
  }

  inline TestReportNodes& operator=(TestReportNodes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestReportNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestReportNodes* internal_default_instance() {
    return reinterpret_cast<const TestReportNodes*>(
               &_TestReportNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TestReportNodes* other);
  friend void swap(TestReportNodes& a, TestReportNodes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestReportNodes* New() const final {
    return CreateMaybeMessage<TestReportNodes>(NULL);
  }

  TestReportNodes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestReportNodes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestReportNodes& from);
  void MergeFrom(const TestReportNodes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestReportNodes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nodes_size = 1;
  bool has_nodes_size() const;
  void clear_nodes_size();
  static const int kNodesSizeFieldNumber = 1;
  ::google::protobuf::int32 nodes_size() const;
  void set_nodes_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.TestReportNodes)
 private:
  void set_has_nodes_size();
  void clear_has_nodes_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 nodes_size_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestConnRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.TestConnRequest) */ {
 public:
  TestConnRequest();
  virtual ~TestConnRequest();

  TestConnRequest(const TestConnRequest& from);

  inline TestConnRequest& operator=(const TestConnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestConnRequest(TestConnRequest&& from) noexcept
    : TestConnRequest() {
    *this = ::std::move(from);
  }

  inline TestConnRequest& operator=(TestConnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConnRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestConnRequest* internal_default_instance() {
    return reinterpret_cast<const TestConnRequest*>(
               &_TestConnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TestConnRequest* other);
  friend void swap(TestConnRequest& a, TestConnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestConnRequest* New() const final {
    return CreateMaybeMessage<TestConnRequest>(NULL);
  }

  TestConnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestConnRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestConnRequest& from);
  void MergeFrom(const TestConnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestConnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_ip = 10;
  bool has_src_ip() const;
  void clear_src_ip();
  static const int kSrcIpFieldNumber = 10;
  const ::std::string& src_ip() const;
  void set_src_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_src_ip(::std::string&& value);
  #endif
  void set_src_ip(const char* value);
  void set_src_ip(const char* value, size_t size);
  ::std::string* mutable_src_ip();
  ::std::string* release_src_ip();
  void set_allocated_src_ip(::std::string* src_ip);

  // required int64 tp1 = 1;
  bool has_tp1() const;
  void clear_tp1();
  static const int kTp1FieldNumber = 1;
  ::google::protobuf::int64 tp1() const;
  void set_tp1(::google::protobuf::int64 value);

  // required int32 src_port = 11;
  bool has_src_port() const;
  void clear_src_port();
  static const int kSrcPortFieldNumber = 11;
  ::google::protobuf::int32 src_port() const;
  void set_src_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.TestConnRequest)
 private:
  void set_has_tp1();
  void clear_has_tp1();
  void set_has_src_ip();
  void clear_has_src_ip();
  void set_has_src_port();
  void clear_has_src_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_ip_;
  ::google::protobuf::int64 tp1_;
  ::google::protobuf::int32 src_port_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestConnResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.TestConnResponse) */ {
 public:
  TestConnResponse();
  virtual ~TestConnResponse();

  TestConnResponse(const TestConnResponse& from);

  inline TestConnResponse& operator=(const TestConnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestConnResponse(TestConnResponse&& from) noexcept
    : TestConnResponse() {
    *this = ::std::move(from);
  }

  inline TestConnResponse& operator=(TestConnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConnResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestConnResponse* internal_default_instance() {
    return reinterpret_cast<const TestConnResponse*>(
               &_TestConnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TestConnResponse* other);
  friend void swap(TestConnResponse& a, TestConnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestConnResponse* New() const final {
    return CreateMaybeMessage<TestConnResponse>(NULL);
  }

  TestConnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestConnResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestConnResponse& from);
  void MergeFrom(const TestConnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestConnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_ip = 10;
  bool has_src_ip() const;
  void clear_src_ip();
  static const int kSrcIpFieldNumber = 10;
  const ::std::string& src_ip() const;
  void set_src_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_src_ip(::std::string&& value);
  #endif
  void set_src_ip(const char* value);
  void set_src_ip(const char* value, size_t size);
  ::std::string* mutable_src_ip();
  ::std::string* release_src_ip();
  void set_allocated_src_ip(::std::string* src_ip);

  // required int64 tp1 = 1;
  bool has_tp1() const;
  void clear_tp1();
  static const int kTp1FieldNumber = 1;
  ::google::protobuf::int64 tp1() const;
  void set_tp1(::google::protobuf::int64 value);

  // required int64 hops1 = 2;
  bool has_hops1() const;
  void clear_hops1();
  static const int kHops1FieldNumber = 2;
  ::google::protobuf::int64 hops1() const;
  void set_hops1(::google::protobuf::int64 value);

  // required int32 src_port = 11;
  bool has_src_port() const;
  void clear_src_port();
  static const int kSrcPortFieldNumber = 11;
  ::google::protobuf::int32 src_port() const;
  void set_src_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.TestConnResponse)
 private:
  void set_has_tp1();
  void clear_has_tp1();
  void set_has_hops1();
  void clear_has_hops1();
  void set_has_src_ip();
  void clear_has_src_ip();
  void set_has_src_port();
  void clear_has_src_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_ip_;
  ::google::protobuf::int64 tp1_;
  ::google::protobuf::int64 hops1_;
  ::google::protobuf::int32 src_port_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestConn2Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.TestConn2Request) */ {
 public:
  TestConn2Request();
  virtual ~TestConn2Request();

  TestConn2Request(const TestConn2Request& from);

  inline TestConn2Request& operator=(const TestConn2Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestConn2Request(TestConn2Request&& from) noexcept
    : TestConn2Request() {
    *this = ::std::move(from);
  }

  inline TestConn2Request& operator=(TestConn2Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConn2Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestConn2Request* internal_default_instance() {
    return reinterpret_cast<const TestConn2Request*>(
               &_TestConn2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TestConn2Request* other);
  friend void swap(TestConn2Request& a, TestConn2Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestConn2Request* New() const final {
    return CreateMaybeMessage<TestConn2Request>(NULL);
  }

  TestConn2Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestConn2Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestConn2Request& from);
  void MergeFrom(const TestConn2Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestConn2Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_ip = 11;
  bool has_src_ip() const;
  void clear_src_ip();
  static const int kSrcIpFieldNumber = 11;
  const ::std::string& src_ip() const;
  void set_src_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_src_ip(::std::string&& value);
  #endif
  void set_src_ip(const char* value);
  void set_src_ip(const char* value, size_t size);
  ::std::string* mutable_src_ip();
  ::std::string* release_src_ip();
  void set_allocated_src_ip(::std::string* src_ip);

  // required int64 tp1 = 1;
  bool has_tp1() const;
  void clear_tp1();
  static const int kTp1FieldNumber = 1;
  ::google::protobuf::int64 tp1() const;
  void set_tp1(::google::protobuf::int64 value);

  // required bool send_or_relay = 10;
  bool has_send_or_relay() const;
  void clear_send_or_relay();
  static const int kSendOrRelayFieldNumber = 10;
  bool send_or_relay() const;
  void set_send_or_relay(bool value);

  // required int32 src_port = 12;
  bool has_src_port() const;
  void clear_src_port();
  static const int kSrcPortFieldNumber = 12;
  ::google::protobuf::int32 src_port() const;
  void set_src_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.TestConn2Request)
 private:
  void set_has_tp1();
  void clear_has_tp1();
  void set_has_send_or_relay();
  void clear_has_send_or_relay();
  void set_has_src_ip();
  void clear_has_src_ip();
  void set_has_src_port();
  void clear_has_src_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_ip_;
  ::google::protobuf::int64 tp1_;
  bool send_or_relay_;
  ::google::protobuf::int32 src_port_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestConn2Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.test.pb.TestConn2Response) */ {
 public:
  TestConn2Response();
  virtual ~TestConn2Response();

  TestConn2Response(const TestConn2Response& from);

  inline TestConn2Response& operator=(const TestConn2Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestConn2Response(TestConn2Response&& from) noexcept
    : TestConn2Response() {
    *this = ::std::move(from);
  }

  inline TestConn2Response& operator=(TestConn2Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConn2Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestConn2Response* internal_default_instance() {
    return reinterpret_cast<const TestConn2Response*>(
               &_TestConn2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TestConn2Response* other);
  friend void swap(TestConn2Response& a, TestConn2Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestConn2Response* New() const final {
    return CreateMaybeMessage<TestConn2Response>(NULL);
  }

  TestConn2Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestConn2Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestConn2Response& from);
  void MergeFrom(const TestConn2Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestConn2Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 tp1 = 1;
  bool has_tp1() const;
  void clear_tp1();
  static const int kTp1FieldNumber = 1;
  ::google::protobuf::int64 tp1() const;
  void set_tp1(::google::protobuf::int64 value);

  // required int64 hops1 = 2;
  bool has_hops1() const;
  void clear_hops1();
  static const int kHops1FieldNumber = 2;
  ::google::protobuf::int64 hops1() const;
  void set_hops1(::google::protobuf::int64 value);

  // required bool send_or_relay = 10;
  bool has_send_or_relay() const;
  void clear_send_or_relay();
  static const int kSendOrRelayFieldNumber = 10;
  bool send_or_relay() const;
  void set_send_or_relay(bool value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.test.pb.TestConn2Response)
 private:
  void set_has_tp1();
  void clear_has_tp1();
  void set_has_hops1();
  void clear_has_hops1();
  void set_has_send_or_relay();
  void clear_has_send_or_relay();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 tp1_;
  ::google::protobuf::int64 hops1_;
  bool send_or_relay_;
  friend struct ::protobuf_node_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AllNodes_Node

// required string local_ip = 1;
inline bool AllNodes_Node::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllNodes_Node::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllNodes_Node::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllNodes_Node::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& AllNodes_Node::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.local_ip)
  return local_ip_.GetNoArena();
}
inline void AllNodes_Node::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.local_ip)
}
#if LANG_CXX11
inline void AllNodes_Node::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.AllNodes.Node.local_ip)
}
#endif
inline void AllNodes_Node::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.AllNodes.Node.local_ip)
}
inline void AllNodes_Node::set_local_ip(const char* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.AllNodes.Node.local_ip)
}
inline ::std::string* AllNodes_Node::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.AllNodes.Node.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AllNodes_Node::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.AllNodes.Node.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AllNodes_Node::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.AllNodes.Node.local_ip)
}

// required int32 local_port = 2;
inline bool AllNodes_Node::has_local_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllNodes_Node::set_has_local_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllNodes_Node::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllNodes_Node::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 AllNodes_Node::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.local_port)
  return local_port_;
}
inline void AllNodes_Node::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.local_port)
}

// required string public_ip = 3;
inline bool AllNodes_Node::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllNodes_Node::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllNodes_Node::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllNodes_Node::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& AllNodes_Node::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.public_ip)
  return public_ip_.GetNoArena();
}
inline void AllNodes_Node::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.public_ip)
}
#if LANG_CXX11
inline void AllNodes_Node::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.AllNodes.Node.public_ip)
}
#endif
inline void AllNodes_Node::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.AllNodes.Node.public_ip)
}
inline void AllNodes_Node::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.AllNodes.Node.public_ip)
}
inline ::std::string* AllNodes_Node::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.AllNodes.Node.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AllNodes_Node::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.AllNodes.Node.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AllNodes_Node::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.AllNodes.Node.public_ip)
}

// required int32 public_port = 4;
inline bool AllNodes_Node::has_public_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AllNodes_Node::set_has_public_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AllNodes_Node::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AllNodes_Node::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 AllNodes_Node::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.public_port)
  return public_port_;
}
inline void AllNodes_Node::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.public_port)
}

// required uint64 service_type = 5;
inline bool AllNodes_Node::has_service_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AllNodes_Node::set_has_service_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AllNodes_Node::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AllNodes_Node::clear_service_type() {
  service_type_ = GOOGLE_ULONGLONG(0);
  clear_has_service_type();
}
inline ::google::protobuf::uint64 AllNodes_Node::service_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.service_type)
  return service_type_;
}
inline void AllNodes_Node::set_service_type(::google::protobuf::uint64 value) {
  set_has_service_type();
  service_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.service_type)
}

// required int32 nat_type = 6;
inline bool AllNodes_Node::has_nat_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AllNodes_Node::set_has_nat_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AllNodes_Node::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AllNodes_Node::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 AllNodes_Node::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.nat_type)
  return nat_type_;
}
inline void AllNodes_Node::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.nat_type)
}

// required bytes node_id = 10;
inline bool AllNodes_Node::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllNodes_Node::set_has_node_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllNodes_Node::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllNodes_Node::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_id();
}
inline const ::std::string& AllNodes_Node::node_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.Node.node_id)
  return node_id_.GetNoArena();
}
inline void AllNodes_Node::set_node_id(const ::std::string& value) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.AllNodes.Node.node_id)
}
#if LANG_CXX11
inline void AllNodes_Node::set_node_id(::std::string&& value) {
  set_has_node_id();
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.AllNodes.Node.node_id)
}
#endif
inline void AllNodes_Node::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.AllNodes.Node.node_id)
}
inline void AllNodes_Node::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.AllNodes.Node.node_id)
}
inline ::std::string* AllNodes_Node::mutable_node_id() {
  set_has_node_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.AllNodes.Node.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AllNodes_Node::release_node_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.AllNodes.Node.node_id)
  if (!has_node_id()) {
    return NULL;
  }
  clear_has_node_id();
  return node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AllNodes_Node::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.AllNodes.Node.node_id)
}

// -------------------------------------------------------------------

// AllNodes

// repeated .top.kadmlia.test.pb.AllNodes.Node nodes = 1;
inline int AllNodes::nodes_size() const {
  return nodes_.size();
}
inline void AllNodes::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::test::pb::AllNodes_Node* AllNodes::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.AllNodes.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::test::pb::AllNodes_Node >*
AllNodes::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.test.pb.AllNodes.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::test::pb::AllNodes_Node& AllNodes::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.AllNodes.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::test::pb::AllNodes_Node* AllNodes::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.test.pb.AllNodes.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::test::pb::AllNodes_Node >&
AllNodes::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.test.pb.AllNodes.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// TestReportNodes

// required int32 nodes_size = 1;
inline bool TestReportNodes::has_nodes_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestReportNodes::set_has_nodes_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestReportNodes::clear_has_nodes_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestReportNodes::clear_nodes_size() {
  nodes_size_ = 0;
  clear_has_nodes_size();
}
inline ::google::protobuf::int32 TestReportNodes::nodes_size() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestReportNodes.nodes_size)
  return nodes_size_;
}
inline void TestReportNodes::set_nodes_size(::google::protobuf::int32 value) {
  set_has_nodes_size();
  nodes_size_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestReportNodes.nodes_size)
}

// -------------------------------------------------------------------

// TestConnRequest

// required int64 tp1 = 1;
inline bool TestConnRequest::has_tp1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConnRequest::set_has_tp1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConnRequest::clear_has_tp1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConnRequest::clear_tp1() {
  tp1_ = GOOGLE_LONGLONG(0);
  clear_has_tp1();
}
inline ::google::protobuf::int64 TestConnRequest::tp1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnRequest.tp1)
  return tp1_;
}
inline void TestConnRequest::set_tp1(::google::protobuf::int64 value) {
  set_has_tp1();
  tp1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnRequest.tp1)
}

// required string src_ip = 10;
inline bool TestConnRequest::has_src_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConnRequest::set_has_src_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConnRequest::clear_has_src_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConnRequest::clear_src_ip() {
  src_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_ip();
}
inline const ::std::string& TestConnRequest::src_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnRequest.src_ip)
  return src_ip_.GetNoArena();
}
inline void TestConnRequest::set_src_ip(const ::std::string& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnRequest.src_ip)
}
#if LANG_CXX11
inline void TestConnRequest::set_src_ip(::std::string&& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.TestConnRequest.src_ip)
}
#endif
inline void TestConnRequest::set_src_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.TestConnRequest.src_ip)
}
inline void TestConnRequest::set_src_ip(const char* value, size_t size) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.TestConnRequest.src_ip)
}
inline ::std::string* TestConnRequest::mutable_src_ip() {
  set_has_src_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.TestConnRequest.src_ip)
  return src_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConnRequest::release_src_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.TestConnRequest.src_ip)
  if (!has_src_ip()) {
    return NULL;
  }
  clear_has_src_ip();
  return src_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConnRequest::set_allocated_src_ip(::std::string* src_ip) {
  if (src_ip != NULL) {
    set_has_src_ip();
  } else {
    clear_has_src_ip();
  }
  src_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.TestConnRequest.src_ip)
}

// required int32 src_port = 11;
inline bool TestConnRequest::has_src_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConnRequest::set_has_src_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConnRequest::clear_has_src_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConnRequest::clear_src_port() {
  src_port_ = 0;
  clear_has_src_port();
}
inline ::google::protobuf::int32 TestConnRequest::src_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnRequest.src_port)
  return src_port_;
}
inline void TestConnRequest::set_src_port(::google::protobuf::int32 value) {
  set_has_src_port();
  src_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnRequest.src_port)
}

// -------------------------------------------------------------------

// TestConnResponse

// required int64 tp1 = 1;
inline bool TestConnResponse::has_tp1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConnResponse::set_has_tp1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConnResponse::clear_has_tp1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConnResponse::clear_tp1() {
  tp1_ = GOOGLE_LONGLONG(0);
  clear_has_tp1();
}
inline ::google::protobuf::int64 TestConnResponse::tp1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnResponse.tp1)
  return tp1_;
}
inline void TestConnResponse::set_tp1(::google::protobuf::int64 value) {
  set_has_tp1();
  tp1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnResponse.tp1)
}

// required int64 hops1 = 2;
inline bool TestConnResponse::has_hops1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConnResponse::set_has_hops1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConnResponse::clear_has_hops1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConnResponse::clear_hops1() {
  hops1_ = GOOGLE_LONGLONG(0);
  clear_has_hops1();
}
inline ::google::protobuf::int64 TestConnResponse::hops1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnResponse.hops1)
  return hops1_;
}
inline void TestConnResponse::set_hops1(::google::protobuf::int64 value) {
  set_has_hops1();
  hops1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnResponse.hops1)
}

// required string src_ip = 10;
inline bool TestConnResponse::has_src_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConnResponse::set_has_src_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConnResponse::clear_has_src_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConnResponse::clear_src_ip() {
  src_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_ip();
}
inline const ::std::string& TestConnResponse::src_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnResponse.src_ip)
  return src_ip_.GetNoArena();
}
inline void TestConnResponse::set_src_ip(const ::std::string& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnResponse.src_ip)
}
#if LANG_CXX11
inline void TestConnResponse::set_src_ip(::std::string&& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.TestConnResponse.src_ip)
}
#endif
inline void TestConnResponse::set_src_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.TestConnResponse.src_ip)
}
inline void TestConnResponse::set_src_ip(const char* value, size_t size) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.TestConnResponse.src_ip)
}
inline ::std::string* TestConnResponse::mutable_src_ip() {
  set_has_src_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.TestConnResponse.src_ip)
  return src_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConnResponse::release_src_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.TestConnResponse.src_ip)
  if (!has_src_ip()) {
    return NULL;
  }
  clear_has_src_ip();
  return src_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConnResponse::set_allocated_src_ip(::std::string* src_ip) {
  if (src_ip != NULL) {
    set_has_src_ip();
  } else {
    clear_has_src_ip();
  }
  src_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.TestConnResponse.src_ip)
}

// required int32 src_port = 11;
inline bool TestConnResponse::has_src_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConnResponse::set_has_src_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConnResponse::clear_has_src_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConnResponse::clear_src_port() {
  src_port_ = 0;
  clear_has_src_port();
}
inline ::google::protobuf::int32 TestConnResponse::src_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConnResponse.src_port)
  return src_port_;
}
inline void TestConnResponse::set_src_port(::google::protobuf::int32 value) {
  set_has_src_port();
  src_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConnResponse.src_port)
}

// -------------------------------------------------------------------

// TestConn2Request

// required int64 tp1 = 1;
inline bool TestConn2Request::has_tp1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConn2Request::set_has_tp1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConn2Request::clear_has_tp1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConn2Request::clear_tp1() {
  tp1_ = GOOGLE_LONGLONG(0);
  clear_has_tp1();
}
inline ::google::protobuf::int64 TestConn2Request::tp1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Request.tp1)
  return tp1_;
}
inline void TestConn2Request::set_tp1(::google::protobuf::int64 value) {
  set_has_tp1();
  tp1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Request.tp1)
}

// required bool send_or_relay = 10;
inline bool TestConn2Request::has_send_or_relay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConn2Request::set_has_send_or_relay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConn2Request::clear_has_send_or_relay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConn2Request::clear_send_or_relay() {
  send_or_relay_ = false;
  clear_has_send_or_relay();
}
inline bool TestConn2Request::send_or_relay() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Request.send_or_relay)
  return send_or_relay_;
}
inline void TestConn2Request::set_send_or_relay(bool value) {
  set_has_send_or_relay();
  send_or_relay_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Request.send_or_relay)
}

// required string src_ip = 11;
inline bool TestConn2Request::has_src_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConn2Request::set_has_src_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConn2Request::clear_has_src_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConn2Request::clear_src_ip() {
  src_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_ip();
}
inline const ::std::string& TestConn2Request::src_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Request.src_ip)
  return src_ip_.GetNoArena();
}
inline void TestConn2Request::set_src_ip(const ::std::string& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Request.src_ip)
}
#if LANG_CXX11
inline void TestConn2Request::set_src_ip(::std::string&& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.test.pb.TestConn2Request.src_ip)
}
#endif
inline void TestConn2Request::set_src_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.test.pb.TestConn2Request.src_ip)
}
inline void TestConn2Request::set_src_ip(const char* value, size_t size) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.test.pb.TestConn2Request.src_ip)
}
inline ::std::string* TestConn2Request::mutable_src_ip() {
  set_has_src_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.test.pb.TestConn2Request.src_ip)
  return src_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConn2Request::release_src_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.test.pb.TestConn2Request.src_ip)
  if (!has_src_ip()) {
    return NULL;
  }
  clear_has_src_ip();
  return src_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConn2Request::set_allocated_src_ip(::std::string* src_ip) {
  if (src_ip != NULL) {
    set_has_src_ip();
  } else {
    clear_has_src_ip();
  }
  src_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.test.pb.TestConn2Request.src_ip)
}

// required int32 src_port = 12;
inline bool TestConn2Request::has_src_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConn2Request::set_has_src_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConn2Request::clear_has_src_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConn2Request::clear_src_port() {
  src_port_ = 0;
  clear_has_src_port();
}
inline ::google::protobuf::int32 TestConn2Request::src_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Request.src_port)
  return src_port_;
}
inline void TestConn2Request::set_src_port(::google::protobuf::int32 value) {
  set_has_src_port();
  src_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Request.src_port)
}

// -------------------------------------------------------------------

// TestConn2Response

// required int64 tp1 = 1;
inline bool TestConn2Response::has_tp1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConn2Response::set_has_tp1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConn2Response::clear_has_tp1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConn2Response::clear_tp1() {
  tp1_ = GOOGLE_LONGLONG(0);
  clear_has_tp1();
}
inline ::google::protobuf::int64 TestConn2Response::tp1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Response.tp1)
  return tp1_;
}
inline void TestConn2Response::set_tp1(::google::protobuf::int64 value) {
  set_has_tp1();
  tp1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Response.tp1)
}

// required int64 hops1 = 2;
inline bool TestConn2Response::has_hops1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConn2Response::set_has_hops1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConn2Response::clear_has_hops1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConn2Response::clear_hops1() {
  hops1_ = GOOGLE_LONGLONG(0);
  clear_has_hops1();
}
inline ::google::protobuf::int64 TestConn2Response::hops1() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Response.hops1)
  return hops1_;
}
inline void TestConn2Response::set_hops1(::google::protobuf::int64 value) {
  set_has_hops1();
  hops1_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Response.hops1)
}

// required bool send_or_relay = 10;
inline bool TestConn2Response::has_send_or_relay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConn2Response::set_has_send_or_relay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConn2Response::clear_has_send_or_relay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConn2Response::clear_send_or_relay() {
  send_or_relay_ = false;
  clear_has_send_or_relay();
}
inline bool TestConn2Response::send_or_relay() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.test.pb.TestConn2Response.send_or_relay)
  return send_or_relay_;
}
inline void TestConn2Response::set_send_or_relay(bool value) {
  set_has_send_or_relay();
  send_or_relay_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.test.pb.TestConn2Response.send_or_relay)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace test
}  // namespace kadmlia
}  // namespace top

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_node_2eproto
