// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kadmlia.proto

#ifndef PROTOBUF_INCLUDED_kadmlia_2eproto
#define PROTOBUF_INCLUDED_kadmlia_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_kadmlia_2eproto 

namespace protobuf_kadmlia_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[38];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_kadmlia_2eproto
namespace top {
namespace kadmlia {
namespace protobuf {
class AddressInfo;
class AddressInfoDefaultTypeInternal;
extern AddressInfoDefaultTypeInternal _AddressInfo_default_instance_;
class BootstrapJoinRequest;
class BootstrapJoinRequestDefaultTypeInternal;
extern BootstrapJoinRequestDefaultTypeInternal _BootstrapJoinRequest_default_instance_;
class BootstrapJoinResponse;
class BootstrapJoinResponseDefaultTypeInternal;
extern BootstrapJoinResponseDefaultTypeInternal _BootstrapJoinResponse_default_instance_;
class ConnectReq;
class ConnectReqDefaultTypeInternal;
extern ConnectReqDefaultTypeInternal _ConnectReq_default_instance_;
class ConnectRes;
class ConnectResDefaultTypeInternal;
extern ConnectResDefaultTypeInternal _ConnectRes_default_instance_;
class EdgeInfoRequest;
class EdgeInfoRequestDefaultTypeInternal;
extern EdgeInfoRequestDefaultTypeInternal _EdgeInfoRequest_default_instance_;
class EdgeInfoRequest_ClientInfoEntry_DoNotUse;
class EdgeInfoRequest_ClientInfoEntry_DoNotUseDefaultTypeInternal;
extern EdgeInfoRequest_ClientInfoEntry_DoNotUseDefaultTypeInternal _EdgeInfoRequest_ClientInfoEntry_DoNotUse_default_instance_;
class EdgeInfoResponse;
class EdgeInfoResponseDefaultTypeInternal;
extern EdgeInfoResponseDefaultTypeInternal _EdgeInfoResponse_default_instance_;
class EdgeInfoResponse_EdgeInfoEntry_DoNotUse;
class EdgeInfoResponse_EdgeInfoEntry_DoNotUseDefaultTypeInternal;
extern EdgeInfoResponse_EdgeInfoEntry_DoNotUseDefaultTypeInternal _EdgeInfoResponse_EdgeInfoEntry_DoNotUse_default_instance_;
class EdgeNodesRequest;
class EdgeNodesRequestDefaultTypeInternal;
extern EdgeNodesRequestDefaultTypeInternal _EdgeNodesRequest_default_instance_;
class EdgeNodesResponse;
class EdgeNodesResponseDefaultTypeInternal;
extern EdgeNodesResponseDefaultTypeInternal _EdgeNodesResponse_default_instance_;
class FindClosestNodesRequest;
class FindClosestNodesRequestDefaultTypeInternal;
extern FindClosestNodesRequestDefaultTypeInternal _FindClosestNodesRequest_default_instance_;
class FindClosestNodesResponse;
class FindClosestNodesResponseDefaultTypeInternal;
extern FindClosestNodesResponseDefaultTypeInternal _FindClosestNodesResponse_default_instance_;
class GetAllNodesFromBootRequest;
class GetAllNodesFromBootRequestDefaultTypeInternal;
extern GetAllNodesFromBootRequestDefaultTypeInternal _GetAllNodesFromBootRequest_default_instance_;
class GetAllNodesFromBootResponse;
class GetAllNodesFromBootResponseDefaultTypeInternal;
extern GetAllNodesFromBootResponseDefaultTypeInternal _GetAllNodesFromBootResponse_default_instance_;
class GetNearestNodesRequest;
class GetNearestNodesRequestDefaultTypeInternal;
extern GetNearestNodesRequestDefaultTypeInternal _GetNearestNodesRequest_default_instance_;
class GetNearestNodesResponse;
class GetNearestNodesResponseDefaultTypeInternal;
extern GetNearestNodesResponseDefaultTypeInternal _GetNearestNodesResponse_default_instance_;
class Handshake;
class HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class Heartbeat;
class HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class Heartbeat_ExtinfoMapEntry_DoNotUse;
class Heartbeat_ExtinfoMapEntry_DoNotUseDefaultTypeInternal;
extern Heartbeat_ExtinfoMapEntry_DoNotUseDefaultTypeInternal _Heartbeat_ExtinfoMapEntry_DoNotUse_default_instance_;
class NatDetectFinish;
class NatDetectFinishDefaultTypeInternal;
extern NatDetectFinishDefaultTypeInternal _NatDetectFinish_default_instance_;
class NatDetectHandshake2Boot;
class NatDetectHandshake2BootDefaultTypeInternal;
extern NatDetectHandshake2BootDefaultTypeInternal _NatDetectHandshake2Boot_default_instance_;
class NatDetectHandshake2Node;
class NatDetectHandshake2NodeDefaultTypeInternal;
extern NatDetectHandshake2NodeDefaultTypeInternal _NatDetectHandshake2Node_default_instance_;
class NatDetectRequest;
class NatDetectRequestDefaultTypeInternal;
extern NatDetectRequestDefaultTypeInternal _NatDetectRequest_default_instance_;
class NatDetectResponse;
class NatDetectResponseDefaultTypeInternal;
extern NatDetectResponseDefaultTypeInternal _NatDetectResponse_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class RootGetNodesRequest;
class RootGetNodesRequestDefaultTypeInternal;
extern RootGetNodesRequestDefaultTypeInternal _RootGetNodesRequest_default_instance_;
class RootGetNodesResponse;
class RootGetNodesResponseDefaultTypeInternal;
extern RootGetNodesResponseDefaultTypeInternal _RootGetNodesResponse_default_instance_;
class RootMessage;
class RootMessageDefaultTypeInternal;
extern RootMessageDefaultTypeInternal _RootMessage_default_instance_;
class SmartObjectData;
class SmartObjectDataDefaultTypeInternal;
extern SmartObjectDataDefaultTypeInternal _SmartObjectData_default_instance_;
class SmartObjectDataBlock;
class SmartObjectDataBlockDefaultTypeInternal;
extern SmartObjectDataBlockDefaultTypeInternal _SmartObjectDataBlock_default_instance_;
class SmartObjectRefreshData;
class SmartObjectRefreshDataDefaultTypeInternal;
extern SmartObjectRefreshDataDefaultTypeInternal _SmartObjectRefreshData_default_instance_;
class SmartObjectSyncData;
class SmartObjectSyncDataDefaultTypeInternal;
extern SmartObjectSyncDataDefaultTypeInternal _SmartObjectSyncData_default_instance_;
class SmartObjectTuple;
class SmartObjectTupleDefaultTypeInternal;
extern SmartObjectTupleDefaultTypeInternal _SmartObjectTuple_default_instance_;
class TestMultiRelayRequest;
class TestMultiRelayRequestDefaultTypeInternal;
extern TestMultiRelayRequestDefaultTypeInternal _TestMultiRelayRequest_default_instance_;
class TestMultiRelayResponse;
class TestMultiRelayResponseDefaultTypeInternal;
extern TestMultiRelayResponseDefaultTypeInternal _TestMultiRelayResponse_default_instance_;
class UdpNatDetectRequest;
class UdpNatDetectRequestDefaultTypeInternal;
extern UdpNatDetectRequestDefaultTypeInternal _UdpNatDetectRequest_default_instance_;
class UdpNatDetectResponse;
class UdpNatDetectResponseDefaultTypeInternal;
extern UdpNatDetectResponseDefaultTypeInternal _UdpNatDetectResponse_default_instance_;
}  // namespace protobuf
}  // namespace kadmlia
}  // namespace top
namespace google {
namespace protobuf {
template<> ::top::kadmlia::protobuf::AddressInfo* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::AddressInfo>(Arena*);
template<> ::top::kadmlia::protobuf::BootstrapJoinRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::BootstrapJoinRequest>(Arena*);
template<> ::top::kadmlia::protobuf::BootstrapJoinResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::BootstrapJoinResponse>(Arena*);
template<> ::top::kadmlia::protobuf::ConnectReq* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::ConnectReq>(Arena*);
template<> ::top::kadmlia::protobuf::ConnectRes* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::ConnectRes>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeInfoRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeInfoRequest>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeInfoRequest_ClientInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeInfoRequest_ClientInfoEntry_DoNotUse>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeInfoResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeInfoResponse>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeInfoResponse_EdgeInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeInfoResponse_EdgeInfoEntry_DoNotUse>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeNodesRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeNodesRequest>(Arena*);
template<> ::top::kadmlia::protobuf::EdgeNodesResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::EdgeNodesResponse>(Arena*);
template<> ::top::kadmlia::protobuf::FindClosestNodesRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::FindClosestNodesRequest>(Arena*);
template<> ::top::kadmlia::protobuf::FindClosestNodesResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::FindClosestNodesResponse>(Arena*);
template<> ::top::kadmlia::protobuf::GetAllNodesFromBootRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::GetAllNodesFromBootRequest>(Arena*);
template<> ::top::kadmlia::protobuf::GetAllNodesFromBootResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::GetAllNodesFromBootResponse>(Arena*);
template<> ::top::kadmlia::protobuf::GetNearestNodesRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::GetNearestNodesRequest>(Arena*);
template<> ::top::kadmlia::protobuf::GetNearestNodesResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::GetNearestNodesResponse>(Arena*);
template<> ::top::kadmlia::protobuf::Handshake* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::Handshake>(Arena*);
template<> ::top::kadmlia::protobuf::Heartbeat* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::Heartbeat>(Arena*);
template<> ::top::kadmlia::protobuf::Heartbeat_ExtinfoMapEntry_DoNotUse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::Heartbeat_ExtinfoMapEntry_DoNotUse>(Arena*);
template<> ::top::kadmlia::protobuf::NatDetectFinish* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NatDetectFinish>(Arena*);
template<> ::top::kadmlia::protobuf::NatDetectHandshake2Boot* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NatDetectHandshake2Boot>(Arena*);
template<> ::top::kadmlia::protobuf::NatDetectHandshake2Node* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NatDetectHandshake2Node>(Arena*);
template<> ::top::kadmlia::protobuf::NatDetectRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NatDetectRequest>(Arena*);
template<> ::top::kadmlia::protobuf::NatDetectResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NatDetectResponse>(Arena*);
template<> ::top::kadmlia::protobuf::NodeInfo* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::NodeInfo>(Arena*);
template<> ::top::kadmlia::protobuf::RootGetNodesRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::RootGetNodesRequest>(Arena*);
template<> ::top::kadmlia::protobuf::RootGetNodesResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::RootGetNodesResponse>(Arena*);
template<> ::top::kadmlia::protobuf::RootMessage* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::RootMessage>(Arena*);
template<> ::top::kadmlia::protobuf::SmartObjectData* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::SmartObjectData>(Arena*);
template<> ::top::kadmlia::protobuf::SmartObjectDataBlock* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::SmartObjectDataBlock>(Arena*);
template<> ::top::kadmlia::protobuf::SmartObjectRefreshData* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::SmartObjectRefreshData>(Arena*);
template<> ::top::kadmlia::protobuf::SmartObjectSyncData* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::SmartObjectSyncData>(Arena*);
template<> ::top::kadmlia::protobuf::SmartObjectTuple* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::SmartObjectTuple>(Arena*);
template<> ::top::kadmlia::protobuf::TestMultiRelayRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::TestMultiRelayRequest>(Arena*);
template<> ::top::kadmlia::protobuf::TestMultiRelayResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::TestMultiRelayResponse>(Arena*);
template<> ::top::kadmlia::protobuf::UdpNatDetectRequest* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::UdpNatDetectRequest>(Arena*);
template<> ::top::kadmlia::protobuf::UdpNatDetectResponse* Arena::CreateMaybeMessage<::top::kadmlia::protobuf::UdpNatDetectResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace top {
namespace kadmlia {
namespace protobuf {

// ===================================================================

class TestMultiRelayRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.TestMultiRelayRequest) */ {
 public:
  TestMultiRelayRequest();
  virtual ~TestMultiRelayRequest();

  TestMultiRelayRequest(const TestMultiRelayRequest& from);

  inline TestMultiRelayRequest& operator=(const TestMultiRelayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestMultiRelayRequest(TestMultiRelayRequest&& from) noexcept
    : TestMultiRelayRequest() {
    *this = ::std::move(from);
  }

  inline TestMultiRelayRequest& operator=(TestMultiRelayRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMultiRelayRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMultiRelayRequest* internal_default_instance() {
    return reinterpret_cast<const TestMultiRelayRequest*>(
               &_TestMultiRelayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TestMultiRelayRequest* other);
  friend void swap(TestMultiRelayRequest& a, TestMultiRelayRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestMultiRelayRequest* New() const final {
    return CreateMaybeMessage<TestMultiRelayRequest>(NULL);
  }

  TestMultiRelayRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestMultiRelayRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestMultiRelayRequest& from);
  void MergeFrom(const TestMultiRelayRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRelayRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ping = 1;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 1;
  const ::std::string& ping() const;
  void set_ping(const ::std::string& value);
  #if LANG_CXX11
  void set_ping(::std::string&& value);
  #endif
  void set_ping(const char* value);
  void set_ping(const void* value, size_t size);
  ::std::string* mutable_ping();
  ::std::string* release_ping();
  void set_allocated_ping(::std::string* ping);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.TestMultiRelayRequest)
 private:
  void set_has_ping();
  void clear_has_ping();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ping_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestMultiRelayResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.TestMultiRelayResponse) */ {
 public:
  TestMultiRelayResponse();
  virtual ~TestMultiRelayResponse();

  TestMultiRelayResponse(const TestMultiRelayResponse& from);

  inline TestMultiRelayResponse& operator=(const TestMultiRelayResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestMultiRelayResponse(TestMultiRelayResponse&& from) noexcept
    : TestMultiRelayResponse() {
    *this = ::std::move(from);
  }

  inline TestMultiRelayResponse& operator=(TestMultiRelayResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMultiRelayResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMultiRelayResponse* internal_default_instance() {
    return reinterpret_cast<const TestMultiRelayResponse*>(
               &_TestMultiRelayResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TestMultiRelayResponse* other);
  friend void swap(TestMultiRelayResponse& a, TestMultiRelayResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestMultiRelayResponse* New() const final {
    return CreateMaybeMessage<TestMultiRelayResponse>(NULL);
  }

  TestMultiRelayResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestMultiRelayResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestMultiRelayResponse& from);
  void MergeFrom(const TestMultiRelayResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMultiRelayResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pong = 1;
  bool has_pong() const;
  void clear_pong();
  static const int kPongFieldNumber = 1;
  const ::std::string& pong() const;
  void set_pong(const ::std::string& value);
  #if LANG_CXX11
  void set_pong(::std::string&& value);
  #endif
  void set_pong(const char* value);
  void set_pong(const void* value, size_t size);
  ::std::string* mutable_pong();
  ::std::string* release_pong();
  void set_allocated_pong(::std::string* pong);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.TestMultiRelayResponse)
 private:
  void set_has_pong();
  void clear_has_pong();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pong_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.ConnectReq) */ {
 public:
  ConnectReq();
  virtual ~ConnectReq();

  ConnectReq(const ConnectReq& from);

  inline ConnectReq& operator=(const ConnectReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectReq(ConnectReq&& from) noexcept
    : ConnectReq() {
    *this = ::std::move(from);
  }

  inline ConnectReq& operator=(ConnectReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectReq* internal_default_instance() {
    return reinterpret_cast<const ConnectReq*>(
               &_ConnectReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ConnectReq* other);
  friend void swap(ConnectReq& a, ConnectReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectReq* New() const final {
    return CreateMaybeMessage<ConnectReq>(NULL);
  }

  ConnectReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectReq& from);
  void MergeFrom(const ConnectReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes public_ip = 3;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 3;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes relay_routing_id = 6;
  bool has_relay_routing_id() const;
  void clear_relay_routing_id();
  static const int kRelayRoutingIdFieldNumber = 6;
  const ::std::string& relay_routing_id() const;
  void set_relay_routing_id(const ::std::string& value);
  #if LANG_CXX11
  void set_relay_routing_id(::std::string&& value);
  #endif
  void set_relay_routing_id(const char* value);
  void set_relay_routing_id(const void* value, size_t size);
  ::std::string* mutable_relay_routing_id();
  ::std::string* release_relay_routing_id();
  void set_allocated_relay_routing_id(::std::string* relay_routing_id);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 public_port = 4;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 4;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 5;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 5;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.ConnectReq)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_relay_routing_id();
  void clear_has_relay_routing_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr relay_routing_id_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.ConnectRes) */ {
 public:
  ConnectRes();
  virtual ~ConnectRes();

  ConnectRes(const ConnectRes& from);

  inline ConnectRes& operator=(const ConnectRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectRes(ConnectRes&& from) noexcept
    : ConnectRes() {
    *this = ::std::move(from);
  }

  inline ConnectRes& operator=(ConnectRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectRes* internal_default_instance() {
    return reinterpret_cast<const ConnectRes*>(
               &_ConnectRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ConnectRes* other);
  friend void swap(ConnectRes& a, ConnectRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectRes* New() const final {
    return CreateMaybeMessage<ConnectRes>(NULL);
  }

  ConnectRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectRes& from);
  void MergeFrom(const ConnectRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes local_ip = 3;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 3;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional int32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 local_port = 4;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 5;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 5;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.ConnectRes)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_nat_type();
  void clear_has_nat_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BootstrapJoinRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.BootstrapJoinRequest) */ {
 public:
  BootstrapJoinRequest();
  virtual ~BootstrapJoinRequest();

  BootstrapJoinRequest(const BootstrapJoinRequest& from);

  inline BootstrapJoinRequest& operator=(const BootstrapJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapJoinRequest(BootstrapJoinRequest&& from) noexcept
    : BootstrapJoinRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapJoinRequest& operator=(BootstrapJoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapJoinRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapJoinRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapJoinRequest*>(
               &_BootstrapJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BootstrapJoinRequest* other);
  friend void swap(BootstrapJoinRequest& a, BootstrapJoinRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapJoinRequest* New() const final {
    return CreateMaybeMessage<BootstrapJoinRequest>(NULL);
  }

  BootstrapJoinRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapJoinRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapJoinRequest& from);
  void MergeFrom(const BootstrapJoinRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapJoinRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes xid = 5;
  bool has_xid() const;
  void clear_xid();
  static const int kXidFieldNumber = 5;
  const ::std::string& xid() const;
  void set_xid(const ::std::string& value);
  #if LANG_CXX11
  void set_xid(::std::string&& value);
  #endif
  void set_xid(const char* value);
  void set_xid(const void* value, size_t size);
  ::std::string* mutable_xid();
  ::std::string* release_xid();
  void set_allocated_xid(::std::string* xid);

  // optional bytes xip = 6;
  bool has_xip() const;
  void clear_xip();
  static const int kXipFieldNumber = 6;
  const ::std::string& xip() const;
  void set_xip(const ::std::string& value);
  #if LANG_CXX11
  void set_xip(::std::string&& value);
  #endif
  void set_xip(const char* value);
  void set_xip(const void* value, size_t size);
  ::std::string* mutable_xip();
  ::std::string* release_xip();
  void set_allocated_xip(::std::string* xip);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional bool client_mode = 3;
  bool has_client_mode() const;
  void clear_client_mode();
  static const int kClientModeFieldNumber = 3;
  bool client_mode() const;
  void set_client_mode(bool value);

  // optional int32 nat_type = 4;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 4;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.BootstrapJoinRequest)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_client_mode();
  void clear_has_client_mode();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_xid();
  void clear_has_xid();
  void set_has_xip();
  void clear_has_xip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr xid_;
  ::google::protobuf::internal::ArenaStringPtr xip_;
  ::google::protobuf::int32 local_port_;
  bool client_mode_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BootstrapJoinResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.BootstrapJoinResponse) */ {
 public:
  BootstrapJoinResponse();
  virtual ~BootstrapJoinResponse();

  BootstrapJoinResponse(const BootstrapJoinResponse& from);

  inline BootstrapJoinResponse& operator=(const BootstrapJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapJoinResponse(BootstrapJoinResponse&& from) noexcept
    : BootstrapJoinResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapJoinResponse& operator=(BootstrapJoinResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapJoinResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapJoinResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapJoinResponse*>(
               &_BootstrapJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BootstrapJoinResponse* other);
  friend void swap(BootstrapJoinResponse& a, BootstrapJoinResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapJoinResponse* New() const final {
    return CreateMaybeMessage<BootstrapJoinResponse>(NULL);
  }

  BootstrapJoinResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapJoinResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapJoinResponse& from);
  void MergeFrom(const BootstrapJoinResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapJoinResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes bootstrap_id = 3;
  bool has_bootstrap_id() const;
  void clear_bootstrap_id();
  static const int kBootstrapIdFieldNumber = 3;
  const ::std::string& bootstrap_id() const;
  void set_bootstrap_id(const ::std::string& value);
  #if LANG_CXX11
  void set_bootstrap_id(::std::string&& value);
  #endif
  void set_bootstrap_id(const char* value);
  void set_bootstrap_id(const void* value, size_t size);
  ::std::string* mutable_bootstrap_id();
  ::std::string* release_bootstrap_id();
  void set_allocated_bootstrap_id(::std::string* bootstrap_id);

  // optional bytes xid = 5;
  bool has_xid() const;
  void clear_xid();
  static const int kXidFieldNumber = 5;
  const ::std::string& xid() const;
  void set_xid(const ::std::string& value);
  #if LANG_CXX11
  void set_xid(::std::string&& value);
  #endif
  void set_xid(const char* value);
  void set_xid(const void* value, size_t size);
  ::std::string* mutable_xid();
  ::std::string* release_xid();
  void set_allocated_xid(::std::string* xid);

  // optional bytes xip = 6;
  bool has_xip() const;
  void clear_xip();
  static const int kXipFieldNumber = 6;
  const ::std::string& xip() const;
  void set_xip(const ::std::string& value);
  #if LANG_CXX11
  void set_xip(::std::string&& value);
  #endif
  void set_xip(const char* value);
  void set_xip(const void* value, size_t size);
  ::std::string* mutable_xip();
  ::std::string* release_xip();
  void set_allocated_xip(::std::string* xip);

  // optional bytes dxip = 7;
  bool has_dxip() const;
  void clear_dxip();
  static const int kDxipFieldNumber = 7;
  const ::std::string& dxip() const;
  void set_dxip(const ::std::string& value);
  #if LANG_CXX11
  void set_dxip(::std::string&& value);
  #endif
  void set_dxip(const char* value);
  void set_dxip(const void* value, size_t size);
  ::std::string* mutable_dxip();
  ::std::string* release_dxip();
  void set_allocated_dxip(::std::string* dxip);

  // optional int32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 4;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 4;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.BootstrapJoinResponse)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_bootstrap_id();
  void clear_has_bootstrap_id();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_xid();
  void clear_has_xid();
  void set_has_xip();
  void clear_has_xip();
  void set_has_dxip();
  void clear_has_dxip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr bootstrap_id_;
  ::google::protobuf::internal::ArenaStringPtr xid_;
  ::google::protobuf::internal::ArenaStringPtr xip_;
  ::google::protobuf::internal::ArenaStringPtr dxip_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NatDetectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NatDetectRequest) */ {
 public:
  NatDetectRequest();
  virtual ~NatDetectRequest();

  NatDetectRequest(const NatDetectRequest& from);

  inline NatDetectRequest& operator=(const NatDetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NatDetectRequest(NatDetectRequest&& from) noexcept
    : NatDetectRequest() {
    *this = ::std::move(from);
  }

  inline NatDetectRequest& operator=(NatDetectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NatDetectRequest* internal_default_instance() {
    return reinterpret_cast<const NatDetectRequest*>(
               &_NatDetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NatDetectRequest* other);
  friend void swap(NatDetectRequest& a, NatDetectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NatDetectRequest* New() const final {
    return CreateMaybeMessage<NatDetectRequest>(NULL);
  }

  NatDetectRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NatDetectRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NatDetectRequest& from);
  void MergeFrom(const NatDetectRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NatDetectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NatDetectRequest)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::int32 local_port_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NatDetectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NatDetectResponse) */ {
 public:
  NatDetectResponse();
  virtual ~NatDetectResponse();

  NatDetectResponse(const NatDetectResponse& from);

  inline NatDetectResponse& operator=(const NatDetectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NatDetectResponse(NatDetectResponse&& from) noexcept
    : NatDetectResponse() {
    *this = ::std::move(from);
  }

  inline NatDetectResponse& operator=(NatDetectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NatDetectResponse* internal_default_instance() {
    return reinterpret_cast<const NatDetectResponse*>(
               &_NatDetectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NatDetectResponse* other);
  friend void swap(NatDetectResponse& a, NatDetectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NatDetectResponse* New() const final {
    return CreateMaybeMessage<NatDetectResponse>(NULL);
  }

  NatDetectResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NatDetectResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NatDetectResponse& from);
  void MergeFrom(const NatDetectResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NatDetectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 nat_type = 1;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 1;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // optional int32 detect_port = 2;
  bool has_detect_port() const;
  void clear_detect_port();
  static const int kDetectPortFieldNumber = 2;
  ::google::protobuf::int32 detect_port() const;
  void set_detect_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NatDetectResponse)
 private:
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_detect_port();
  void clear_has_detect_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 nat_type_;
  ::google::protobuf::int32 detect_port_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NatDetectFinish : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NatDetectFinish) */ {
 public:
  NatDetectFinish();
  virtual ~NatDetectFinish();

  NatDetectFinish(const NatDetectFinish& from);

  inline NatDetectFinish& operator=(const NatDetectFinish& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NatDetectFinish(NatDetectFinish&& from) noexcept
    : NatDetectFinish() {
    *this = ::std::move(from);
  }

  inline NatDetectFinish& operator=(NatDetectFinish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectFinish& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NatDetectFinish* internal_default_instance() {
    return reinterpret_cast<const NatDetectFinish*>(
               &_NatDetectFinish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(NatDetectFinish* other);
  friend void swap(NatDetectFinish& a, NatDetectFinish& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NatDetectFinish* New() const final {
    return CreateMaybeMessage<NatDetectFinish>(NULL);
  }

  NatDetectFinish* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NatDetectFinish>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NatDetectFinish& from);
  void MergeFrom(const NatDetectFinish& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NatDetectFinish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 resv = 1;
  bool has_resv() const;
  void clear_resv();
  static const int kResvFieldNumber = 1;
  ::google::protobuf::int32 resv() const;
  void set_resv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NatDetectFinish)
 private:
  void set_has_resv();
  void clear_has_resv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 resv_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NatDetectHandshake2Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NatDetectHandshake2Node) */ {
 public:
  NatDetectHandshake2Node();
  virtual ~NatDetectHandshake2Node();

  NatDetectHandshake2Node(const NatDetectHandshake2Node& from);

  inline NatDetectHandshake2Node& operator=(const NatDetectHandshake2Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NatDetectHandshake2Node(NatDetectHandshake2Node&& from) noexcept
    : NatDetectHandshake2Node() {
    *this = ::std::move(from);
  }

  inline NatDetectHandshake2Node& operator=(NatDetectHandshake2Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectHandshake2Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NatDetectHandshake2Node* internal_default_instance() {
    return reinterpret_cast<const NatDetectHandshake2Node*>(
               &_NatDetectHandshake2Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(NatDetectHandshake2Node* other);
  friend void swap(NatDetectHandshake2Node& a, NatDetectHandshake2Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NatDetectHandshake2Node* New() const final {
    return CreateMaybeMessage<NatDetectHandshake2Node>(NULL);
  }

  NatDetectHandshake2Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NatDetectHandshake2Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NatDetectHandshake2Node& from);
  void MergeFrom(const NatDetectHandshake2Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NatDetectHandshake2Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 resv = 1;
  bool has_resv() const;
  void clear_resv();
  static const int kResvFieldNumber = 1;
  ::google::protobuf::int32 resv() const;
  void set_resv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NatDetectHandshake2Node)
 private:
  void set_has_resv();
  void clear_has_resv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 resv_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NatDetectHandshake2Boot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NatDetectHandshake2Boot) */ {
 public:
  NatDetectHandshake2Boot();
  virtual ~NatDetectHandshake2Boot();

  NatDetectHandshake2Boot(const NatDetectHandshake2Boot& from);

  inline NatDetectHandshake2Boot& operator=(const NatDetectHandshake2Boot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NatDetectHandshake2Boot(NatDetectHandshake2Boot&& from) noexcept
    : NatDetectHandshake2Boot() {
    *this = ::std::move(from);
  }

  inline NatDetectHandshake2Boot& operator=(NatDetectHandshake2Boot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectHandshake2Boot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NatDetectHandshake2Boot* internal_default_instance() {
    return reinterpret_cast<const NatDetectHandshake2Boot*>(
               &_NatDetectHandshake2Boot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(NatDetectHandshake2Boot* other);
  friend void swap(NatDetectHandshake2Boot& a, NatDetectHandshake2Boot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NatDetectHandshake2Boot* New() const final {
    return CreateMaybeMessage<NatDetectHandshake2Boot>(NULL);
  }

  NatDetectHandshake2Boot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NatDetectHandshake2Boot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NatDetectHandshake2Boot& from);
  void MergeFrom(const NatDetectHandshake2Boot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NatDetectHandshake2Boot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 resv = 1;
  bool has_resv() const;
  void clear_resv();
  static const int kResvFieldNumber = 1;
  ::google::protobuf::int32 resv() const;
  void set_resv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NatDetectHandshake2Boot)
 private:
  void set_has_resv();
  void clear_has_resv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 resv_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Handshake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.Handshake) */ {
 public:
  Handshake();
  virtual ~Handshake();

  Handshake(const Handshake& from);

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(Handshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Handshake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Handshake* other);
  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Handshake* New() const final {
    return CreateMaybeMessage<Handshake>(NULL);
  }

  Handshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Handshake& from);
  void MergeFrom(const Handshake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes public_ip = 4;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 4;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes xid = 7;
  bool has_xid() const;
  void clear_xid();
  static const int kXidFieldNumber = 7;
  const ::std::string& xid() const;
  void set_xid(const ::std::string& value);
  #if LANG_CXX11
  void set_xid(::std::string&& value);
  #endif
  void set_xid(const char* value);
  void set_xid(const void* value, size_t size);
  ::std::string* mutable_xid();
  ::std::string* release_xid();
  void set_allocated_xid(::std::string* xid);

  // optional bytes xip = 8;
  bool has_xip() const;
  void clear_xip();
  static const int kXipFieldNumber = 8;
  const ::std::string& xip() const;
  void set_xip(const ::std::string& value);
  #if LANG_CXX11
  void set_xip(::std::string&& value);
  #endif
  void set_xip(const char* value);
  void set_xip(const void* value, size_t size);
  ::std::string* mutable_xip();
  ::std::string* release_xip();
  void set_allocated_xip(::std::string* xip);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 public_port = 5;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 5;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 6;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 6;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.Handshake)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_type();
  void clear_has_type();
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_xid();
  void clear_has_xid();
  void set_has_xip();
  void clear_has_xip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr xid_;
  ::google::protobuf::internal::ArenaStringPtr xip_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(NULL);
  }

  NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes local_ip = 3;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 3;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes id = 5;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 5;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bytes xip = 7;
  bool has_xip() const;
  void clear_xip();
  static const int kXipFieldNumber = 7;
  const ::std::string& xip() const;
  void set_xip(const ::std::string& value);
  #if LANG_CXX11
  void set_xip(::std::string&& value);
  #endif
  void set_xip(const char* value);
  void set_xip(const void* value, size_t size);
  ::std::string* mutable_xip();
  ::std::string* release_xip();
  void set_allocated_xip(::std::string* xip);

  // optional bytes xid = 8;
  bool has_xid() const;
  void clear_xid();
  static const int kXidFieldNumber = 8;
  const ::std::string& xid() const;
  void set_xid(const ::std::string& value);
  #if LANG_CXX11
  void set_xid(::std::string&& value);
  #endif
  void set_xid(const char* value);
  void set_xid(const void* value, size_t size);
  ::std::string* mutable_xid();
  ::std::string* release_xid();
  void set_allocated_xid(::std::string* xid);

  // optional int32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 local_port = 4;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 6;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 6;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.NodeInfo)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_id();
  void clear_has_id();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_xip();
  void clear_has_xip();
  void set_has_xid();
  void clear_has_xid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr xip_;
  ::google::protobuf::internal::ArenaStringPtr xid_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Heartbeat_ExtinfoMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Heartbeat_ExtinfoMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Heartbeat_ExtinfoMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Heartbeat_ExtinfoMapEntry_DoNotUse();
  Heartbeat_ExtinfoMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Heartbeat_ExtinfoMapEntry_DoNotUse& other);
  static const Heartbeat_ExtinfoMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Heartbeat_ExtinfoMapEntry_DoNotUse*>(&_Heartbeat_ExtinfoMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.Heartbeat) */ {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Heartbeat* other);
  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const final {
    return CreateMaybeMessage<Heartbeat>(NULL);
  }

  Heartbeat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> extinfo_map = 1;
  int extinfo_map_size() const;
  void clear_extinfo_map();
  static const int kExtinfoMapFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      extinfo_map() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_extinfo_map();

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.Heartbeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      Heartbeat_ExtinfoMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > extinfo_map_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindClosestNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.FindClosestNodesRequest) */ {
 public:
  FindClosestNodesRequest();
  virtual ~FindClosestNodesRequest();

  FindClosestNodesRequest(const FindClosestNodesRequest& from);

  inline FindClosestNodesRequest& operator=(const FindClosestNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindClosestNodesRequest(FindClosestNodesRequest&& from) noexcept
    : FindClosestNodesRequest() {
    *this = ::std::move(from);
  }

  inline FindClosestNodesRequest& operator=(FindClosestNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FindClosestNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindClosestNodesRequest* internal_default_instance() {
    return reinterpret_cast<const FindClosestNodesRequest*>(
               &_FindClosestNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(FindClosestNodesRequest* other);
  friend void swap(FindClosestNodesRequest& a, FindClosestNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindClosestNodesRequest* New() const final {
    return CreateMaybeMessage<FindClosestNodesRequest>(NULL);
  }

  FindClosestNodesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindClosestNodesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindClosestNodesRequest& from);
  void MergeFrom(const FindClosestNodesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindClosestNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 bloomfilter = 3;
  int bloomfilter_size() const;
  void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 3;
  ::google::protobuf::uint64 bloomfilter(int index) const;
  void set_bloomfilter(int index, ::google::protobuf::uint64 value);
  void add_bloomfilter(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter();

  // optional bytes target_id = 2;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  const ::std::string& target_id() const;
  void set_target_id(const ::std::string& value);
  #if LANG_CXX11
  void set_target_id(::std::string&& value);
  #endif
  void set_target_id(const char* value);
  void set_target_id(const void* value, size_t size);
  ::std::string* mutable_target_id();
  ::std::string* release_target_id();
  void set_allocated_target_id(::std::string* target_id);

  // optional .top.kadmlia.protobuf.NodeInfo src_nodeinfo = 4;
  bool has_src_nodeinfo() const;
  void clear_src_nodeinfo();
  static const int kSrcNodeinfoFieldNumber = 4;
  private:
  const ::top::kadmlia::protobuf::NodeInfo& _internal_src_nodeinfo() const;
  public:
  const ::top::kadmlia::protobuf::NodeInfo& src_nodeinfo() const;
  ::top::kadmlia::protobuf::NodeInfo* release_src_nodeinfo();
  ::top::kadmlia::protobuf::NodeInfo* mutable_src_nodeinfo();
  void set_allocated_src_nodeinfo(::top::kadmlia::protobuf::NodeInfo* src_nodeinfo);

  // optional uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.FindClosestNodesRequest)
 private:
  void set_has_count();
  void clear_has_count();
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_src_nodeinfo();
  void clear_has_src_nodeinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter_;
  ::google::protobuf::internal::ArenaStringPtr target_id_;
  ::top::kadmlia::protobuf::NodeInfo* src_nodeinfo_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindClosestNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.FindClosestNodesResponse) */ {
 public:
  FindClosestNodesResponse();
  virtual ~FindClosestNodesResponse();

  FindClosestNodesResponse(const FindClosestNodesResponse& from);

  inline FindClosestNodesResponse& operator=(const FindClosestNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindClosestNodesResponse(FindClosestNodesResponse&& from) noexcept
    : FindClosestNodesResponse() {
    *this = ::std::move(from);
  }

  inline FindClosestNodesResponse& operator=(FindClosestNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FindClosestNodesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindClosestNodesResponse* internal_default_instance() {
    return reinterpret_cast<const FindClosestNodesResponse*>(
               &_FindClosestNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(FindClosestNodesResponse* other);
  friend void swap(FindClosestNodesResponse& a, FindClosestNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindClosestNodesResponse* New() const final {
    return CreateMaybeMessage<FindClosestNodesResponse>(NULL);
  }

  FindClosestNodesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindClosestNodesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindClosestNodesResponse& from);
  void MergeFrom(const FindClosestNodesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindClosestNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
      mutable_nodes();
  const ::top::kadmlia::protobuf::NodeInfo& nodes(int index) const;
  ::top::kadmlia::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.FindClosestNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNearestNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.GetNearestNodesRequest) */ {
 public:
  GetNearestNodesRequest();
  virtual ~GetNearestNodesRequest();

  GetNearestNodesRequest(const GetNearestNodesRequest& from);

  inline GetNearestNodesRequest& operator=(const GetNearestNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNearestNodesRequest(GetNearestNodesRequest&& from) noexcept
    : GetNearestNodesRequest() {
    *this = ::std::move(from);
  }

  inline GetNearestNodesRequest& operator=(GetNearestNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNearestNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNearestNodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetNearestNodesRequest*>(
               &_GetNearestNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetNearestNodesRequest* other);
  friend void swap(GetNearestNodesRequest& a, GetNearestNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNearestNodesRequest* New() const final {
    return CreateMaybeMessage<GetNearestNodesRequest>(NULL);
  }

  GetNearestNodesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetNearestNodesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetNearestNodesRequest& from);
  void MergeFrom(const GetNearestNodesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNearestNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes target_id = 1;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  const ::std::string& target_id() const;
  void set_target_id(const ::std::string& value);
  #if LANG_CXX11
  void set_target_id(::std::string&& value);
  #endif
  void set_target_id(const char* value);
  void set_target_id(const void* value, size_t size);
  ::std::string* mutable_target_id();
  ::std::string* release_target_id();
  void set_allocated_target_id(::std::string* target_id);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.GetNearestNodesRequest)
 private:
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr target_id_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNearestNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.GetNearestNodesResponse) */ {
 public:
  GetNearestNodesResponse();
  virtual ~GetNearestNodesResponse();

  GetNearestNodesResponse(const GetNearestNodesResponse& from);

  inline GetNearestNodesResponse& operator=(const GetNearestNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNearestNodesResponse(GetNearestNodesResponse&& from) noexcept
    : GetNearestNodesResponse() {
    *this = ::std::move(from);
  }

  inline GetNearestNodesResponse& operator=(GetNearestNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNearestNodesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNearestNodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetNearestNodesResponse*>(
               &_GetNearestNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetNearestNodesResponse* other);
  friend void swap(GetNearestNodesResponse& a, GetNearestNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNearestNodesResponse* New() const final {
    return CreateMaybeMessage<GetNearestNodesResponse>(NULL);
  }

  GetNearestNodesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetNearestNodesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetNearestNodesResponse& from);
  void MergeFrom(const GetNearestNodesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNearestNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
      mutable_nodes();
  const ::top::kadmlia::protobuf::NodeInfo& nodes(int index) const;
  ::top::kadmlia::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.GetNearestNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UdpNatDetectRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.UdpNatDetectRequest) */ {
 public:
  UdpNatDetectRequest();
  virtual ~UdpNatDetectRequest();

  UdpNatDetectRequest(const UdpNatDetectRequest& from);

  inline UdpNatDetectRequest& operator=(const UdpNatDetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UdpNatDetectRequest(UdpNatDetectRequest&& from) noexcept
    : UdpNatDetectRequest() {
    *this = ::std::move(from);
  }

  inline UdpNatDetectRequest& operator=(UdpNatDetectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdpNatDetectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UdpNatDetectRequest* internal_default_instance() {
    return reinterpret_cast<const UdpNatDetectRequest*>(
               &_UdpNatDetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(UdpNatDetectRequest* other);
  friend void swap(UdpNatDetectRequest& a, UdpNatDetectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UdpNatDetectRequest* New() const final {
    return CreateMaybeMessage<UdpNatDetectRequest>(NULL);
  }

  UdpNatDetectRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UdpNatDetectRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UdpNatDetectRequest& from);
  void MergeFrom(const UdpNatDetectRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UdpNatDetectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 resv = 1;
  bool has_resv() const;
  void clear_resv();
  static const int kResvFieldNumber = 1;
  ::google::protobuf::uint32 resv() const;
  void set_resv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.UdpNatDetectRequest)
 private:
  void set_has_resv();
  void clear_has_resv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 resv_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UdpNatDetectResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.UdpNatDetectResponse) */ {
 public:
  UdpNatDetectResponse();
  virtual ~UdpNatDetectResponse();

  UdpNatDetectResponse(const UdpNatDetectResponse& from);

  inline UdpNatDetectResponse& operator=(const UdpNatDetectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UdpNatDetectResponse(UdpNatDetectResponse&& from) noexcept
    : UdpNatDetectResponse() {
    *this = ::std::move(from);
  }

  inline UdpNatDetectResponse& operator=(UdpNatDetectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdpNatDetectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UdpNatDetectResponse* internal_default_instance() {
    return reinterpret_cast<const UdpNatDetectResponse*>(
               &_UdpNatDetectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(UdpNatDetectResponse* other);
  friend void swap(UdpNatDetectResponse& a, UdpNatDetectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UdpNatDetectResponse* New() const final {
    return CreateMaybeMessage<UdpNatDetectResponse>(NULL);
  }

  UdpNatDetectResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UdpNatDetectResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UdpNatDetectResponse& from);
  void MergeFrom(const UdpNatDetectResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UdpNatDetectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional int32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.UdpNatDetectResponse)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::int32 public_port_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.EdgeNodesRequest) */ {
 public:
  EdgeNodesRequest();
  virtual ~EdgeNodesRequest();

  EdgeNodesRequest(const EdgeNodesRequest& from);

  inline EdgeNodesRequest& operator=(const EdgeNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeNodesRequest(EdgeNodesRequest&& from) noexcept
    : EdgeNodesRequest() {
    *this = ::std::move(from);
  }

  inline EdgeNodesRequest& operator=(EdgeNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeNodesRequest* internal_default_instance() {
    return reinterpret_cast<const EdgeNodesRequest*>(
               &_EdgeNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(EdgeNodesRequest* other);
  friend void swap(EdgeNodesRequest& a, EdgeNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeNodesRequest* New() const final {
    return CreateMaybeMessage<EdgeNodesRequest>(NULL);
  }

  EdgeNodesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeNodesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeNodesRequest& from);
  void MergeFrom(const EdgeNodesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes target_id = 1;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 1;
  const ::std::string& target_id() const;
  void set_target_id(const ::std::string& value);
  #if LANG_CXX11
  void set_target_id(::std::string&& value);
  #endif
  void set_target_id(const char* value);
  void set_target_id(const void* value, size_t size);
  ::std::string* mutable_target_id();
  ::std::string* release_target_id();
  void set_allocated_target_id(::std::string* target_id);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.EdgeNodesRequest)
 private:
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr target_id_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.EdgeNodesResponse) */ {
 public:
  EdgeNodesResponse();
  virtual ~EdgeNodesResponse();

  EdgeNodesResponse(const EdgeNodesResponse& from);

  inline EdgeNodesResponse& operator=(const EdgeNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeNodesResponse(EdgeNodesResponse&& from) noexcept
    : EdgeNodesResponse() {
    *this = ::std::move(from);
  }

  inline EdgeNodesResponse& operator=(EdgeNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeNodesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeNodesResponse* internal_default_instance() {
    return reinterpret_cast<const EdgeNodesResponse*>(
               &_EdgeNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(EdgeNodesResponse* other);
  friend void swap(EdgeNodesResponse& a, EdgeNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeNodesResponse* New() const final {
    return CreateMaybeMessage<EdgeNodesResponse>(NULL);
  }

  EdgeNodesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeNodesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeNodesResponse& from);
  void MergeFrom(const EdgeNodesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
      mutable_nodes();
  const ::top::kadmlia::protobuf::NodeInfo& nodes(int index) const;
  ::top::kadmlia::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.EdgeNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddressInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.AddressInfo) */ {
 public:
  AddressInfo();
  virtual ~AddressInfo();

  AddressInfo(const AddressInfo& from);

  inline AddressInfo& operator=(const AddressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddressInfo(AddressInfo&& from) noexcept
    : AddressInfo() {
    *this = ::std::move(from);
  }

  inline AddressInfo& operator=(AddressInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddressInfo* internal_default_instance() {
    return reinterpret_cast<const AddressInfo*>(
               &_AddressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(AddressInfo* other);
  friend void swap(AddressInfo& a, AddressInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddressInfo* New() const final {
    return CreateMaybeMessage<AddressInfo>(NULL);
  }

  AddressInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddressInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddressInfo& from);
  void MergeFrom(const AddressInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes detect_local_ip = 4;
  bool has_detect_local_ip() const;
  void clear_detect_local_ip();
  static const int kDetectLocalIpFieldNumber = 4;
  const ::std::string& detect_local_ip() const;
  void set_detect_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_detect_local_ip(::std::string&& value);
  #endif
  void set_detect_local_ip(const char* value);
  void set_detect_local_ip(const void* value, size_t size);
  ::std::string* mutable_detect_local_ip();
  ::std::string* release_detect_local_ip();
  void set_allocated_detect_local_ip(::std::string* detect_local_ip);

  // optional uint32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::uint32 public_port() const;
  void set_public_port(::google::protobuf::uint32 value);

  // optional uint32 local_port = 3;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 3;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // optional uint32 detect_local_port = 5;
  bool has_detect_local_port() const;
  void clear_detect_local_port();
  static const int kDetectLocalPortFieldNumber = 5;
  ::google::protobuf::uint32 detect_local_port() const;
  void set_detect_local_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.AddressInfo)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_detect_local_ip();
  void clear_has_detect_local_ip();
  void set_has_detect_local_port();
  void clear_has_detect_local_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr detect_local_ip_;
  ::google::protobuf::uint32 public_port_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 detect_local_port_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeInfoRequest_ClientInfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EdgeInfoRequest_ClientInfoEntry_DoNotUse, 
    ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EdgeInfoRequest_ClientInfoEntry_DoNotUse, 
    ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EdgeInfoRequest_ClientInfoEntry_DoNotUse();
  EdgeInfoRequest_ClientInfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EdgeInfoRequest_ClientInfoEntry_DoNotUse& other);
  static const EdgeInfoRequest_ClientInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EdgeInfoRequest_ClientInfoEntry_DoNotUse*>(&_EdgeInfoRequest_ClientInfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EdgeInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.EdgeInfoRequest) */ {
 public:
  EdgeInfoRequest();
  virtual ~EdgeInfoRequest();

  EdgeInfoRequest(const EdgeInfoRequest& from);

  inline EdgeInfoRequest& operator=(const EdgeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeInfoRequest(EdgeInfoRequest&& from) noexcept
    : EdgeInfoRequest() {
    *this = ::std::move(from);
  }

  inline EdgeInfoRequest& operator=(EdgeInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const EdgeInfoRequest*>(
               &_EdgeInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(EdgeInfoRequest* other);
  friend void swap(EdgeInfoRequest& a, EdgeInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeInfoRequest* New() const final {
    return CreateMaybeMessage<EdgeInfoRequest>(NULL);
  }

  EdgeInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeInfoRequest& from);
  void MergeFrom(const EdgeInfoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint32, .top.kadmlia.protobuf.AddressInfo> client_info = 1;
  int client_info_size() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >&
      client_info() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >*
      mutable_client_info();

  // optional int32 nat_type = 2;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 2;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.EdgeInfoRequest)
 private:
  void set_has_nat_type();
  void clear_has_nat_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      EdgeInfoRequest_ClientInfoEntry_DoNotUse,
      ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > client_info_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeInfoResponse_EdgeInfoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EdgeInfoResponse_EdgeInfoEntry_DoNotUse, 
    ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EdgeInfoResponse_EdgeInfoEntry_DoNotUse, 
    ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EdgeInfoResponse_EdgeInfoEntry_DoNotUse();
  EdgeInfoResponse_EdgeInfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EdgeInfoResponse_EdgeInfoEntry_DoNotUse& other);
  static const EdgeInfoResponse_EdgeInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EdgeInfoResponse_EdgeInfoEntry_DoNotUse*>(&_EdgeInfoResponse_EdgeInfoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EdgeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.EdgeInfoResponse) */ {
 public:
  EdgeInfoResponse();
  virtual ~EdgeInfoResponse();

  EdgeInfoResponse(const EdgeInfoResponse& from);

  inline EdgeInfoResponse& operator=(const EdgeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeInfoResponse(EdgeInfoResponse&& from) noexcept
    : EdgeInfoResponse() {
    *this = ::std::move(from);
  }

  inline EdgeInfoResponse& operator=(EdgeInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const EdgeInfoResponse*>(
               &_EdgeInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(EdgeInfoResponse* other);
  friend void swap(EdgeInfoResponse& a, EdgeInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeInfoResponse* New() const final {
    return CreateMaybeMessage<EdgeInfoResponse>(NULL);
  }

  EdgeInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeInfoResponse& from);
  void MergeFrom(const EdgeInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint32, .top.kadmlia.protobuf.AddressInfo> edge_info = 1;
  int edge_info_size() const;
  void clear_edge_info();
  static const int kEdgeInfoFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >&
      edge_info() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >*
      mutable_edge_info();

  // optional int32 nat_type = 2;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 2;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.EdgeInfoResponse)
 private:
  void set_has_nat_type();
  void clear_has_nat_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      EdgeInfoResponse_EdgeInfoEntry_DoNotUse,
      ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > edge_info_;
  ::google::protobuf::int32 nat_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAllNodesFromBootRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.GetAllNodesFromBootRequest) */ {
 public:
  GetAllNodesFromBootRequest();
  virtual ~GetAllNodesFromBootRequest();

  GetAllNodesFromBootRequest(const GetAllNodesFromBootRequest& from);

  inline GetAllNodesFromBootRequest& operator=(const GetAllNodesFromBootRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllNodesFromBootRequest(GetAllNodesFromBootRequest&& from) noexcept
    : GetAllNodesFromBootRequest() {
    *this = ::std::move(from);
  }

  inline GetAllNodesFromBootRequest& operator=(GetAllNodesFromBootRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllNodesFromBootRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllNodesFromBootRequest* internal_default_instance() {
    return reinterpret_cast<const GetAllNodesFromBootRequest*>(
               &_GetAllNodesFromBootRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(GetAllNodesFromBootRequest* other);
  friend void swap(GetAllNodesFromBootRequest& a, GetAllNodesFromBootRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllNodesFromBootRequest* New() const final {
    return CreateMaybeMessage<GetAllNodesFromBootRequest>(NULL);
  }

  GetAllNodesFromBootRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAllNodesFromBootRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAllNodesFromBootRequest& from);
  void MergeFrom(const GetAllNodesFromBootRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllNodesFromBootRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start_pos = 1;
  bool has_start_pos() const;
  void clear_start_pos();
  static const int kStartPosFieldNumber = 1;
  ::google::protobuf::int32 start_pos() const;
  void set_start_pos(::google::protobuf::int32 value);

  // optional int32 len = 2;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 2;
  ::google::protobuf::int32 len() const;
  void set_len(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.GetAllNodesFromBootRequest)
 private:
  void set_has_start_pos();
  void clear_has_start_pos();
  void set_has_len();
  void clear_has_len();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 start_pos_;
  ::google::protobuf::int32 len_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAllNodesFromBootResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.GetAllNodesFromBootResponse) */ {
 public:
  GetAllNodesFromBootResponse();
  virtual ~GetAllNodesFromBootResponse();

  GetAllNodesFromBootResponse(const GetAllNodesFromBootResponse& from);

  inline GetAllNodesFromBootResponse& operator=(const GetAllNodesFromBootResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllNodesFromBootResponse(GetAllNodesFromBootResponse&& from) noexcept
    : GetAllNodesFromBootResponse() {
    *this = ::std::move(from);
  }

  inline GetAllNodesFromBootResponse& operator=(GetAllNodesFromBootResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllNodesFromBootResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllNodesFromBootResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllNodesFromBootResponse*>(
               &_GetAllNodesFromBootResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(GetAllNodesFromBootResponse* other);
  friend void swap(GetAllNodesFromBootResponse& a, GetAllNodesFromBootResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllNodesFromBootResponse* New() const final {
    return CreateMaybeMessage<GetAllNodesFromBootResponse>(NULL);
  }

  GetAllNodesFromBootResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAllNodesFromBootResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAllNodesFromBootResponse& from);
  void MergeFrom(const GetAllNodesFromBootResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllNodesFromBootResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
      mutable_nodes();
  const ::top::kadmlia::protobuf::NodeInfo& nodes(int index) const;
  ::top::kadmlia::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.GetAllNodesFromBootResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmartObjectData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.SmartObjectData) */ {
 public:
  SmartObjectData();
  virtual ~SmartObjectData();

  SmartObjectData(const SmartObjectData& from);

  inline SmartObjectData& operator=(const SmartObjectData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmartObjectData(SmartObjectData&& from) noexcept
    : SmartObjectData() {
    *this = ::std::move(from);
  }

  inline SmartObjectData& operator=(SmartObjectData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartObjectData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmartObjectData* internal_default_instance() {
    return reinterpret_cast<const SmartObjectData*>(
               &_SmartObjectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(SmartObjectData* other);
  friend void swap(SmartObjectData& a, SmartObjectData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmartObjectData* New() const final {
    return CreateMaybeMessage<SmartObjectData>(NULL);
  }

  SmartObjectData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmartObjectData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmartObjectData& from);
  void MergeFrom(const SmartObjectData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartObjectData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes list_value = 6;
  int list_value_size() const;
  void clear_list_value();
  static const int kListValueFieldNumber = 6;
  const ::std::string& list_value(int index) const;
  ::std::string* mutable_list_value(int index);
  void set_list_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_list_value(int index, ::std::string&& value);
  #endif
  void set_list_value(int index, const char* value);
  void set_list_value(int index, const void* value, size_t size);
  ::std::string* add_list_value();
  void add_list_value(const ::std::string& value);
  #if LANG_CXX11
  void add_list_value(::std::string&& value);
  #endif
  void add_list_value(const char* value);
  void add_list_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& list_value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_list_value();

  // optional bytes key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes field = 5;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 5;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const void* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // optional bytes public_key = 8;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 8;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes aes_key = 9;
  bool has_aes_key() const;
  void clear_aes_key();
  static const int kAesKeyFieldNumber = 9;
  const ::std::string& aes_key() const;
  void set_aes_key(const ::std::string& value);
  #if LANG_CXX11
  void set_aes_key(::std::string&& value);
  #endif
  void set_aes_key(const char* value);
  void set_aes_key(const void* value, size_t size);
  ::std::string* mutable_aes_key();
  ::std::string* release_aes_key();
  void set_allocated_aes_key(::std::string* aes_key);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 oper = 2;
  bool has_oper() const;
  void clear_oper();
  static const int kOperFieldNumber = 2;
  ::google::protobuf::uint32 oper() const;
  void set_oper(::google::protobuf::uint32 value);

  // optional uint32 ttl = 7;
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 7;
  ::google::protobuf::uint32 ttl() const;
  void set_ttl(::google::protobuf::uint32 value);

  // optional uint32 encrypt_mode = 10;
  bool has_encrypt_mode() const;
  void clear_encrypt_mode();
  static const int kEncryptModeFieldNumber = 10;
  ::google::protobuf::uint32 encrypt_mode() const;
  void set_encrypt_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.SmartObjectData)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_oper();
  void clear_has_oper();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_field();
  void clear_has_field();
  void set_has_ttl();
  void clear_has_ttl();
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_aes_key();
  void clear_has_aes_key();
  void set_has_encrypt_mode();
  void clear_has_encrypt_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> list_value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr aes_key_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 oper_;
  ::google::protobuf::uint32 ttl_;
  ::google::protobuf::uint32 encrypt_mode_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmartObjectTuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.SmartObjectTuple) */ {
 public:
  SmartObjectTuple();
  virtual ~SmartObjectTuple();

  SmartObjectTuple(const SmartObjectTuple& from);

  inline SmartObjectTuple& operator=(const SmartObjectTuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmartObjectTuple(SmartObjectTuple&& from) noexcept
    : SmartObjectTuple() {
    *this = ::std::move(from);
  }

  inline SmartObjectTuple& operator=(SmartObjectTuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartObjectTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmartObjectTuple* internal_default_instance() {
    return reinterpret_cast<const SmartObjectTuple*>(
               &_SmartObjectTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(SmartObjectTuple* other);
  friend void swap(SmartObjectTuple& a, SmartObjectTuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmartObjectTuple* New() const final {
    return CreateMaybeMessage<SmartObjectTuple>(NULL);
  }

  SmartObjectTuple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmartObjectTuple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmartObjectTuple& from);
  void MergeFrom(const SmartObjectTuple& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartObjectTuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes list_value = 5;
  int list_value_size() const;
  void clear_list_value();
  static const int kListValueFieldNumber = 5;
  const ::std::string& list_value(int index) const;
  ::std::string* mutable_list_value(int index);
  void set_list_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_list_value(int index, ::std::string&& value);
  #endif
  void set_list_value(int index, const char* value);
  void set_list_value(int index, const void* value, size_t size);
  ::std::string* add_list_value();
  void add_list_value(const ::std::string& value);
  #if LANG_CXX11
  void add_list_value(::std::string&& value);
  #endif
  void add_list_value(const char* value);
  void add_list_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& list_value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_list_value();

  // optional bytes key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes field = 4;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 4;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const void* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 ttl = 7;
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 7;
  ::google::protobuf::uint32 ttl() const;
  void set_ttl(::google::protobuf::uint32 value);

  // optional uint64 save_time = 6;
  bool has_save_time() const;
  void clear_save_time();
  static const int kSaveTimeFieldNumber = 6;
  ::google::protobuf::uint64 save_time() const;
  void set_save_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.SmartObjectTuple)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_field();
  void clear_has_field();
  void set_has_save_time();
  void clear_has_save_time();
  void set_has_ttl();
  void clear_has_ttl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> list_value_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 ttl_;
  ::google::protobuf::uint64 save_time_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmartObjectRefreshData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.SmartObjectRefreshData) */ {
 public:
  SmartObjectRefreshData();
  virtual ~SmartObjectRefreshData();

  SmartObjectRefreshData(const SmartObjectRefreshData& from);

  inline SmartObjectRefreshData& operator=(const SmartObjectRefreshData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmartObjectRefreshData(SmartObjectRefreshData&& from) noexcept
    : SmartObjectRefreshData() {
    *this = ::std::move(from);
  }

  inline SmartObjectRefreshData& operator=(SmartObjectRefreshData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartObjectRefreshData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmartObjectRefreshData* internal_default_instance() {
    return reinterpret_cast<const SmartObjectRefreshData*>(
               &_SmartObjectRefreshData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(SmartObjectRefreshData* other);
  friend void swap(SmartObjectRefreshData& a, SmartObjectRefreshData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmartObjectRefreshData* New() const final {
    return CreateMaybeMessage<SmartObjectRefreshData>(NULL);
  }

  SmartObjectRefreshData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmartObjectRefreshData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmartObjectRefreshData& from);
  void MergeFrom(const SmartObjectRefreshData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartObjectRefreshData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.SmartObjectTuple list_tuple = 2;
  int list_tuple_size() const;
  void clear_list_tuple();
  static const int kListTupleFieldNumber = 2;
  ::top::kadmlia::protobuf::SmartObjectTuple* mutable_list_tuple(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectTuple >*
      mutable_list_tuple();
  const ::top::kadmlia::protobuf::SmartObjectTuple& list_tuple(int index) const;
  ::top::kadmlia::protobuf::SmartObjectTuple* add_list_tuple();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectTuple >&
      list_tuple() const;

  // optional uint32 oper = 1;
  bool has_oper() const;
  void clear_oper();
  static const int kOperFieldNumber = 1;
  ::google::protobuf::uint32 oper() const;
  void set_oper(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.SmartObjectRefreshData)
 private:
  void set_has_oper();
  void clear_has_oper();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectTuple > list_tuple_;
  ::google::protobuf::uint32 oper_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmartObjectDataBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.SmartObjectDataBlock) */ {
 public:
  SmartObjectDataBlock();
  virtual ~SmartObjectDataBlock();

  SmartObjectDataBlock(const SmartObjectDataBlock& from);

  inline SmartObjectDataBlock& operator=(const SmartObjectDataBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmartObjectDataBlock(SmartObjectDataBlock&& from) noexcept
    : SmartObjectDataBlock() {
    *this = ::std::move(from);
  }

  inline SmartObjectDataBlock& operator=(SmartObjectDataBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartObjectDataBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmartObjectDataBlock* internal_default_instance() {
    return reinterpret_cast<const SmartObjectDataBlock*>(
               &_SmartObjectDataBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(SmartObjectDataBlock* other);
  friend void swap(SmartObjectDataBlock& a, SmartObjectDataBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmartObjectDataBlock* New() const final {
    return CreateMaybeMessage<SmartObjectDataBlock>(NULL);
  }

  SmartObjectDataBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmartObjectDataBlock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmartObjectDataBlock& from);
  void MergeFrom(const SmartObjectDataBlock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartObjectDataBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes block_hash = 2;
  bool has_block_hash() const;
  void clear_block_hash();
  static const int kBlockHashFieldNumber = 2;
  const ::std::string& block_hash() const;
  void set_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_block_hash(::std::string&& value);
  #endif
  void set_block_hash(const char* value);
  void set_block_hash(const void* value, size_t size);
  ::std::string* mutable_block_hash();
  ::std::string* release_block_hash();
  void set_allocated_block_hash(::std::string* block_hash);

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.SmartObjectDataBlock)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_block_hash();
  void clear_has_block_hash();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr block_hash_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 id_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SmartObjectSyncData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.SmartObjectSyncData) */ {
 public:
  SmartObjectSyncData();
  virtual ~SmartObjectSyncData();

  SmartObjectSyncData(const SmartObjectSyncData& from);

  inline SmartObjectSyncData& operator=(const SmartObjectSyncData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SmartObjectSyncData(SmartObjectSyncData&& from) noexcept
    : SmartObjectSyncData() {
    *this = ::std::move(from);
  }

  inline SmartObjectSyncData& operator=(SmartObjectSyncData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartObjectSyncData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmartObjectSyncData* internal_default_instance() {
    return reinterpret_cast<const SmartObjectSyncData*>(
               &_SmartObjectSyncData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(SmartObjectSyncData* other);
  friend void swap(SmartObjectSyncData& a, SmartObjectSyncData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SmartObjectSyncData* New() const final {
    return CreateMaybeMessage<SmartObjectSyncData>(NULL);
  }

  SmartObjectSyncData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SmartObjectSyncData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SmartObjectSyncData& from);
  void MergeFrom(const SmartObjectSyncData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartObjectSyncData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.SmartObjectDataBlock list_block = 6;
  int list_block_size() const;
  void clear_list_block();
  static const int kListBlockFieldNumber = 6;
  ::top::kadmlia::protobuf::SmartObjectDataBlock* mutable_list_block(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectDataBlock >*
      mutable_list_block();
  const ::top::kadmlia::protobuf::SmartObjectDataBlock& list_block(int index) const;
  ::top::kadmlia::protobuf::SmartObjectDataBlock* add_list_block();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectDataBlock >&
      list_block() const;

  // optional bytes key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional bytes root_hash = 4;
  bool has_root_hash() const;
  void clear_root_hash();
  static const int kRootHashFieldNumber = 4;
  const ::std::string& root_hash() const;
  void set_root_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_root_hash(::std::string&& value);
  #endif
  void set_root_hash(const char* value);
  void set_root_hash(const void* value, size_t size);
  ::std::string* mutable_root_hash();
  ::std::string* release_root_hash();
  void set_allocated_root_hash(::std::string* root_hash);

  // optional bytes sync_node = 5;
  bool has_sync_node() const;
  void clear_sync_node();
  static const int kSyncNodeFieldNumber = 5;
  const ::std::string& sync_node() const;
  void set_sync_node(const ::std::string& value);
  #if LANG_CXX11
  void set_sync_node(::std::string&& value);
  #endif
  void set_sync_node(const char* value);
  void set_sync_node(const void* value, size_t size);
  ::std::string* mutable_sync_node();
  ::std::string* release_sync_node();
  void set_allocated_sync_node(::std::string* sync_node);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.SmartObjectSyncData)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_key();
  void clear_has_key();
  void set_has_version();
  void clear_has_version();
  void set_has_root_hash();
  void clear_has_root_hash();
  void set_has_sync_node();
  void clear_has_sync_node();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectDataBlock > list_block_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr root_hash_;
  ::google::protobuf::internal::ArenaStringPtr sync_node_;
  ::google::protobuf::uint32 type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RootGetNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.RootGetNodesRequest) */ {
 public:
  RootGetNodesRequest();
  virtual ~RootGetNodesRequest();

  RootGetNodesRequest(const RootGetNodesRequest& from);

  inline RootGetNodesRequest& operator=(const RootGetNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RootGetNodesRequest(RootGetNodesRequest&& from) noexcept
    : RootGetNodesRequest() {
    *this = ::std::move(from);
  }

  inline RootGetNodesRequest& operator=(RootGetNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RootGetNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootGetNodesRequest* internal_default_instance() {
    return reinterpret_cast<const RootGetNodesRequest*>(
               &_RootGetNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(RootGetNodesRequest* other);
  friend void swap(RootGetNodesRequest& a, RootGetNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RootGetNodesRequest* New() const final {
    return CreateMaybeMessage<RootGetNodesRequest>(NULL);
  }

  RootGetNodesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RootGetNodesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RootGetNodesRequest& from);
  void MergeFrom(const RootGetNodesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootGetNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.RootGetNodesRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RootGetNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.RootGetNodesResponse) */ {
 public:
  RootGetNodesResponse();
  virtual ~RootGetNodesResponse();

  RootGetNodesResponse(const RootGetNodesResponse& from);

  inline RootGetNodesResponse& operator=(const RootGetNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RootGetNodesResponse(RootGetNodesResponse&& from) noexcept
    : RootGetNodesResponse() {
    *this = ::std::move(from);
  }

  inline RootGetNodesResponse& operator=(RootGetNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RootGetNodesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootGetNodesResponse* internal_default_instance() {
    return reinterpret_cast<const RootGetNodesResponse*>(
               &_RootGetNodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(RootGetNodesResponse* other);
  friend void swap(RootGetNodesResponse& a, RootGetNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RootGetNodesResponse* New() const final {
    return CreateMaybeMessage<RootGetNodesResponse>(NULL);
  }

  RootGetNodesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RootGetNodesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RootGetNodesResponse& from);
  void MergeFrom(const RootGetNodesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootGetNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::top::kadmlia::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
      mutable_nodes();
  const ::top::kadmlia::protobuf::NodeInfo& nodes(int index) const;
  ::top::kadmlia::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.RootGetNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RootMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:top.kadmlia.protobuf.RootMessage) */ {
 public:
  RootMessage();
  virtual ~RootMessage();

  RootMessage(const RootMessage& from);

  inline RootMessage& operator=(const RootMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RootMessage(RootMessage&& from) noexcept
    : RootMessage() {
    *this = ::std::move(from);
  }

  inline RootMessage& operator=(RootMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RootMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootMessage* internal_default_instance() {
    return reinterpret_cast<const RootMessage*>(
               &_RootMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(RootMessage* other);
  friend void swap(RootMessage& a, RootMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RootMessage* New() const final {
    return CreateMaybeMessage<RootMessage>(NULL);
  }

  RootMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RootMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RootMessage& from);
  void MergeFrom(const RootMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint32 message_type = 1;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::google::protobuf::uint32 message_type() const;
  void set_message_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:top.kadmlia.protobuf.RootMessage)
 private:
  void set_has_message_type();
  void clear_has_message_type();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 message_type_;
  friend struct ::protobuf_kadmlia_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TestMultiRelayRequest

// optional bytes ping = 1;
inline bool TestMultiRelayRequest::has_ping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMultiRelayRequest::set_has_ping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMultiRelayRequest::clear_has_ping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMultiRelayRequest::clear_ping() {
  ping_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ping();
}
inline const ::std::string& TestMultiRelayRequest::ping() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
  return ping_.GetNoArena();
}
inline void TestMultiRelayRequest::set_ping(const ::std::string& value) {
  set_has_ping();
  ping_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
}
#if LANG_CXX11
inline void TestMultiRelayRequest::set_ping(::std::string&& value) {
  set_has_ping();
  ping_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
}
#endif
inline void TestMultiRelayRequest::set_ping(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ping();
  ping_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
}
inline void TestMultiRelayRequest::set_ping(const void* value, size_t size) {
  set_has_ping();
  ping_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
}
inline ::std::string* TestMultiRelayRequest::mutable_ping() {
  set_has_ping();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
  return ping_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestMultiRelayRequest::release_ping() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
  if (!has_ping()) {
    return NULL;
  }
  clear_has_ping();
  return ping_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestMultiRelayRequest::set_allocated_ping(::std::string* ping) {
  if (ping != NULL) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
  ping_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ping);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.TestMultiRelayRequest.ping)
}

// -------------------------------------------------------------------

// TestMultiRelayResponse

// optional bytes pong = 1;
inline bool TestMultiRelayResponse::has_pong() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMultiRelayResponse::set_has_pong() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMultiRelayResponse::clear_has_pong() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMultiRelayResponse::clear_pong() {
  pong_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pong();
}
inline const ::std::string& TestMultiRelayResponse::pong() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
  return pong_.GetNoArena();
}
inline void TestMultiRelayResponse::set_pong(const ::std::string& value) {
  set_has_pong();
  pong_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
}
#if LANG_CXX11
inline void TestMultiRelayResponse::set_pong(::std::string&& value) {
  set_has_pong();
  pong_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
}
#endif
inline void TestMultiRelayResponse::set_pong(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pong();
  pong_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
}
inline void TestMultiRelayResponse::set_pong(const void* value, size_t size) {
  set_has_pong();
  pong_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
}
inline ::std::string* TestMultiRelayResponse::mutable_pong() {
  set_has_pong();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
  return pong_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestMultiRelayResponse::release_pong() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
  if (!has_pong()) {
    return NULL;
  }
  clear_has_pong();
  return pong_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestMultiRelayResponse::set_allocated_pong(::std::string* pong) {
  if (pong != NULL) {
    set_has_pong();
  } else {
    clear_has_pong();
  }
  pong_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pong);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.TestMultiRelayResponse.pong)
}

// -------------------------------------------------------------------

// ConnectReq

// optional bytes local_ip = 1;
inline bool ConnectReq::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectReq::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectReq::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectReq::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& ConnectReq::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.local_ip)
  return local_ip_.GetNoArena();
}
inline void ConnectReq::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.local_ip)
}
#if LANG_CXX11
inline void ConnectReq::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.ConnectReq.local_ip)
}
#endif
inline void ConnectReq::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.ConnectReq.local_ip)
}
inline void ConnectReq::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.ConnectReq.local_ip)
}
inline ::std::string* ConnectReq::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.ConnectReq.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.ConnectReq.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.ConnectReq.local_ip)
}

// optional int32 local_port = 2;
inline bool ConnectReq::has_local_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectReq::set_has_local_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectReq::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectReq::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 ConnectReq::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.local_port)
  return local_port_;
}
inline void ConnectReq::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.local_port)
}

// optional bytes public_ip = 3;
inline bool ConnectReq::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectReq::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectReq::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectReq::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& ConnectReq::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.public_ip)
  return public_ip_.GetNoArena();
}
inline void ConnectReq::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.public_ip)
}
#if LANG_CXX11
inline void ConnectReq::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.ConnectReq.public_ip)
}
#endif
inline void ConnectReq::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.ConnectReq.public_ip)
}
inline void ConnectReq::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.ConnectReq.public_ip)
}
inline ::std::string* ConnectReq::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.ConnectReq.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.ConnectReq.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.ConnectReq.public_ip)
}

// optional int32 public_port = 4;
inline bool ConnectReq::has_public_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectReq::set_has_public_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectReq::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectReq::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 ConnectReq::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.public_port)
  return public_port_;
}
inline void ConnectReq::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.public_port)
}

// optional int32 nat_type = 5;
inline bool ConnectReq::has_nat_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectReq::set_has_nat_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectReq::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectReq::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 ConnectReq::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.nat_type)
  return nat_type_;
}
inline void ConnectReq::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.nat_type)
}

// optional bytes relay_routing_id = 6;
inline bool ConnectReq::has_relay_routing_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectReq::set_has_relay_routing_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectReq::clear_has_relay_routing_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectReq::clear_relay_routing_id() {
  relay_routing_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_relay_routing_id();
}
inline const ::std::string& ConnectReq::relay_routing_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
  return relay_routing_id_.GetNoArena();
}
inline void ConnectReq::set_relay_routing_id(const ::std::string& value) {
  set_has_relay_routing_id();
  relay_routing_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
}
#if LANG_CXX11
inline void ConnectReq::set_relay_routing_id(::std::string&& value) {
  set_has_relay_routing_id();
  relay_routing_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
}
#endif
inline void ConnectReq::set_relay_routing_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_relay_routing_id();
  relay_routing_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
}
inline void ConnectReq::set_relay_routing_id(const void* value, size_t size) {
  set_has_relay_routing_id();
  relay_routing_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
}
inline ::std::string* ConnectReq::mutable_relay_routing_id() {
  set_has_relay_routing_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
  return relay_routing_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_relay_routing_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
  if (!has_relay_routing_id()) {
    return NULL;
  }
  clear_has_relay_routing_id();
  return relay_routing_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_relay_routing_id(::std::string* relay_routing_id) {
  if (relay_routing_id != NULL) {
    set_has_relay_routing_id();
  } else {
    clear_has_relay_routing_id();
  }
  relay_routing_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relay_routing_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.ConnectReq.relay_routing_id)
}

// -------------------------------------------------------------------

// ConnectRes

// optional bytes public_ip = 1;
inline bool ConnectRes::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRes::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRes::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRes::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& ConnectRes::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectRes.public_ip)
  return public_ip_.GetNoArena();
}
inline void ConnectRes::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectRes.public_ip)
}
#if LANG_CXX11
inline void ConnectRes::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.ConnectRes.public_ip)
}
#endif
inline void ConnectRes::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.ConnectRes.public_ip)
}
inline void ConnectRes::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.ConnectRes.public_ip)
}
inline ::std::string* ConnectRes::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.ConnectRes.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectRes::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.ConnectRes.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRes::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.ConnectRes.public_ip)
}

// optional int32 public_port = 2;
inline bool ConnectRes::has_public_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectRes::set_has_public_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectRes::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectRes::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 ConnectRes::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectRes.public_port)
  return public_port_;
}
inline void ConnectRes::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectRes.public_port)
}

// optional bytes local_ip = 3;
inline bool ConnectRes::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRes::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRes::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRes::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& ConnectRes::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectRes.local_ip)
  return local_ip_.GetNoArena();
}
inline void ConnectRes::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectRes.local_ip)
}
#if LANG_CXX11
inline void ConnectRes::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.ConnectRes.local_ip)
}
#endif
inline void ConnectRes::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.ConnectRes.local_ip)
}
inline void ConnectRes::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.ConnectRes.local_ip)
}
inline ::std::string* ConnectRes::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.ConnectRes.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectRes::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.ConnectRes.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRes::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.ConnectRes.local_ip)
}

// optional int32 local_port = 4;
inline bool ConnectRes::has_local_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectRes::set_has_local_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectRes::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectRes::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 ConnectRes::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectRes.local_port)
  return local_port_;
}
inline void ConnectRes::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectRes.local_port)
}

// optional int32 nat_type = 5;
inline bool ConnectRes::has_nat_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectRes::set_has_nat_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectRes::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectRes::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 ConnectRes::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.ConnectRes.nat_type)
  return nat_type_;
}
inline void ConnectRes::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.ConnectRes.nat_type)
}

// -------------------------------------------------------------------

// BootstrapJoinRequest

// optional bytes local_ip = 1;
inline bool BootstrapJoinRequest::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapJoinRequest::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapJoinRequest::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapJoinRequest::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& BootstrapJoinRequest::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
  return local_ip_.GetNoArena();
}
inline void BootstrapJoinRequest::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
}
#if LANG_CXX11
inline void BootstrapJoinRequest::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
}
#endif
inline void BootstrapJoinRequest::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
}
inline void BootstrapJoinRequest::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
}
inline ::std::string* BootstrapJoinRequest::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinRequest::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinRequest::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinRequest.local_ip)
}

// optional int32 local_port = 2;
inline bool BootstrapJoinRequest::has_local_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootstrapJoinRequest::set_has_local_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootstrapJoinRequest::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootstrapJoinRequest::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 BootstrapJoinRequest::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.local_port)
  return local_port_;
}
inline void BootstrapJoinRequest::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.local_port)
}

// optional bool client_mode = 3;
inline bool BootstrapJoinRequest::has_client_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BootstrapJoinRequest::set_has_client_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BootstrapJoinRequest::clear_has_client_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BootstrapJoinRequest::clear_client_mode() {
  client_mode_ = false;
  clear_has_client_mode();
}
inline bool BootstrapJoinRequest::client_mode() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.client_mode)
  return client_mode_;
}
inline void BootstrapJoinRequest::set_client_mode(bool value) {
  set_has_client_mode();
  client_mode_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.client_mode)
}

// optional int32 nat_type = 4;
inline bool BootstrapJoinRequest::has_nat_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BootstrapJoinRequest::set_has_nat_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BootstrapJoinRequest::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BootstrapJoinRequest::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 BootstrapJoinRequest::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.nat_type)
  return nat_type_;
}
inline void BootstrapJoinRequest::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.nat_type)
}

// optional bytes xid = 5;
inline bool BootstrapJoinRequest::has_xid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapJoinRequest::set_has_xid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapJoinRequest::clear_has_xid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapJoinRequest::clear_xid() {
  xid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xid();
}
inline const ::std::string& BootstrapJoinRequest::xid() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
  return xid_.GetNoArena();
}
inline void BootstrapJoinRequest::set_xid(const ::std::string& value) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
}
#if LANG_CXX11
inline void BootstrapJoinRequest::set_xid(::std::string&& value) {
  set_has_xid();
  xid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
}
#endif
inline void BootstrapJoinRequest::set_xid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
}
inline void BootstrapJoinRequest::set_xid(const void* value, size_t size) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
}
inline ::std::string* BootstrapJoinRequest::mutable_xid() {
  set_has_xid();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
  return xid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinRequest::release_xid() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
  if (!has_xid()) {
    return NULL;
  }
  clear_has_xid();
  return xid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinRequest::set_allocated_xid(::std::string* xid) {
  if (xid != NULL) {
    set_has_xid();
  } else {
    clear_has_xid();
  }
  xid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xid);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinRequest.xid)
}

// optional bytes xip = 6;
inline bool BootstrapJoinRequest::has_xip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapJoinRequest::set_has_xip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapJoinRequest::clear_has_xip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapJoinRequest::clear_xip() {
  xip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xip();
}
inline const ::std::string& BootstrapJoinRequest::xip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
  return xip_.GetNoArena();
}
inline void BootstrapJoinRequest::set_xip(const ::std::string& value) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
}
#if LANG_CXX11
inline void BootstrapJoinRequest::set_xip(::std::string&& value) {
  set_has_xip();
  xip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
}
#endif
inline void BootstrapJoinRequest::set_xip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
}
inline void BootstrapJoinRequest::set_xip(const void* value, size_t size) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
}
inline ::std::string* BootstrapJoinRequest::mutable_xip() {
  set_has_xip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
  return xip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinRequest::release_xip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
  if (!has_xip()) {
    return NULL;
  }
  clear_has_xip();
  return xip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinRequest::set_allocated_xip(::std::string* xip) {
  if (xip != NULL) {
    set_has_xip();
  } else {
    clear_has_xip();
  }
  xip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinRequest.xip)
}

// -------------------------------------------------------------------

// BootstrapJoinResponse

// optional bytes public_ip = 1;
inline bool BootstrapJoinResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapJoinResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapJoinResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapJoinResponse::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& BootstrapJoinResponse::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
  return public_ip_.GetNoArena();
}
inline void BootstrapJoinResponse::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
}
#if LANG_CXX11
inline void BootstrapJoinResponse::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
}
#endif
inline void BootstrapJoinResponse::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
}
inline void BootstrapJoinResponse::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
}
inline ::std::string* BootstrapJoinResponse::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinResponse::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinResponse::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinResponse.public_ip)
}

// optional int32 public_port = 2;
inline bool BootstrapJoinResponse::has_public_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BootstrapJoinResponse::set_has_public_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BootstrapJoinResponse::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BootstrapJoinResponse::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 BootstrapJoinResponse::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.public_port)
  return public_port_;
}
inline void BootstrapJoinResponse::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.public_port)
}

// optional bytes bootstrap_id = 3;
inline bool BootstrapJoinResponse::has_bootstrap_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapJoinResponse::set_has_bootstrap_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapJoinResponse::clear_has_bootstrap_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapJoinResponse::clear_bootstrap_id() {
  bootstrap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bootstrap_id();
}
inline const ::std::string& BootstrapJoinResponse::bootstrap_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
  return bootstrap_id_.GetNoArena();
}
inline void BootstrapJoinResponse::set_bootstrap_id(const ::std::string& value) {
  set_has_bootstrap_id();
  bootstrap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
}
#if LANG_CXX11
inline void BootstrapJoinResponse::set_bootstrap_id(::std::string&& value) {
  set_has_bootstrap_id();
  bootstrap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
}
#endif
inline void BootstrapJoinResponse::set_bootstrap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bootstrap_id();
  bootstrap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
}
inline void BootstrapJoinResponse::set_bootstrap_id(const void* value, size_t size) {
  set_has_bootstrap_id();
  bootstrap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
}
inline ::std::string* BootstrapJoinResponse::mutable_bootstrap_id() {
  set_has_bootstrap_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
  return bootstrap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinResponse::release_bootstrap_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
  if (!has_bootstrap_id()) {
    return NULL;
  }
  clear_has_bootstrap_id();
  return bootstrap_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinResponse::set_allocated_bootstrap_id(::std::string* bootstrap_id) {
  if (bootstrap_id != NULL) {
    set_has_bootstrap_id();
  } else {
    clear_has_bootstrap_id();
  }
  bootstrap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bootstrap_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinResponse.bootstrap_id)
}

// optional int32 nat_type = 4;
inline bool BootstrapJoinResponse::has_nat_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BootstrapJoinResponse::set_has_nat_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BootstrapJoinResponse::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BootstrapJoinResponse::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 BootstrapJoinResponse::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.nat_type)
  return nat_type_;
}
inline void BootstrapJoinResponse::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.nat_type)
}

// optional bytes xid = 5;
inline bool BootstrapJoinResponse::has_xid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapJoinResponse::set_has_xid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapJoinResponse::clear_has_xid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapJoinResponse::clear_xid() {
  xid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xid();
}
inline const ::std::string& BootstrapJoinResponse::xid() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
  return xid_.GetNoArena();
}
inline void BootstrapJoinResponse::set_xid(const ::std::string& value) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
}
#if LANG_CXX11
inline void BootstrapJoinResponse::set_xid(::std::string&& value) {
  set_has_xid();
  xid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
}
#endif
inline void BootstrapJoinResponse::set_xid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
}
inline void BootstrapJoinResponse::set_xid(const void* value, size_t size) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
}
inline ::std::string* BootstrapJoinResponse::mutable_xid() {
  set_has_xid();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
  return xid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinResponse::release_xid() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
  if (!has_xid()) {
    return NULL;
  }
  clear_has_xid();
  return xid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinResponse::set_allocated_xid(::std::string* xid) {
  if (xid != NULL) {
    set_has_xid();
  } else {
    clear_has_xid();
  }
  xid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xid);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinResponse.xid)
}

// optional bytes xip = 6;
inline bool BootstrapJoinResponse::has_xip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootstrapJoinResponse::set_has_xip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootstrapJoinResponse::clear_has_xip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootstrapJoinResponse::clear_xip() {
  xip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xip();
}
inline const ::std::string& BootstrapJoinResponse::xip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
  return xip_.GetNoArena();
}
inline void BootstrapJoinResponse::set_xip(const ::std::string& value) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
}
#if LANG_CXX11
inline void BootstrapJoinResponse::set_xip(::std::string&& value) {
  set_has_xip();
  xip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
}
#endif
inline void BootstrapJoinResponse::set_xip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
}
inline void BootstrapJoinResponse::set_xip(const void* value, size_t size) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
}
inline ::std::string* BootstrapJoinResponse::mutable_xip() {
  set_has_xip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
  return xip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinResponse::release_xip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
  if (!has_xip()) {
    return NULL;
  }
  clear_has_xip();
  return xip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinResponse::set_allocated_xip(::std::string* xip) {
  if (xip != NULL) {
    set_has_xip();
  } else {
    clear_has_xip();
  }
  xip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinResponse.xip)
}

// optional bytes dxip = 7;
inline bool BootstrapJoinResponse::has_dxip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BootstrapJoinResponse::set_has_dxip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BootstrapJoinResponse::clear_has_dxip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BootstrapJoinResponse::clear_dxip() {
  dxip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dxip();
}
inline const ::std::string& BootstrapJoinResponse::dxip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
  return dxip_.GetNoArena();
}
inline void BootstrapJoinResponse::set_dxip(const ::std::string& value) {
  set_has_dxip();
  dxip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
}
#if LANG_CXX11
inline void BootstrapJoinResponse::set_dxip(::std::string&& value) {
  set_has_dxip();
  dxip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
}
#endif
inline void BootstrapJoinResponse::set_dxip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dxip();
  dxip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
}
inline void BootstrapJoinResponse::set_dxip(const void* value, size_t size) {
  set_has_dxip();
  dxip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
}
inline ::std::string* BootstrapJoinResponse::mutable_dxip() {
  set_has_dxip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
  return dxip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapJoinResponse::release_dxip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
  if (!has_dxip()) {
    return NULL;
  }
  clear_has_dxip();
  return dxip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapJoinResponse::set_allocated_dxip(::std::string* dxip) {
  if (dxip != NULL) {
    set_has_dxip();
  } else {
    clear_has_dxip();
  }
  dxip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dxip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.BootstrapJoinResponse.dxip)
}

// -------------------------------------------------------------------

// NatDetectRequest

// optional bytes local_ip = 1;
inline bool NatDetectRequest::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NatDetectRequest::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NatDetectRequest::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NatDetectRequest::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& NatDetectRequest::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectRequest.local_ip)
  return local_ip_.GetNoArena();
}
inline void NatDetectRequest::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectRequest.local_ip)
}
#if LANG_CXX11
inline void NatDetectRequest::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NatDetectRequest.local_ip)
}
#endif
inline void NatDetectRequest::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NatDetectRequest.local_ip)
}
inline void NatDetectRequest::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NatDetectRequest.local_ip)
}
inline ::std::string* NatDetectRequest::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NatDetectRequest.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NatDetectRequest::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NatDetectRequest.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NatDetectRequest::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NatDetectRequest.local_ip)
}

// optional int32 local_port = 2;
inline bool NatDetectRequest::has_local_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NatDetectRequest::set_has_local_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NatDetectRequest::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NatDetectRequest::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 NatDetectRequest::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectRequest.local_port)
  return local_port_;
}
inline void NatDetectRequest::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectRequest.local_port)
}

// -------------------------------------------------------------------

// NatDetectResponse

// optional int32 nat_type = 1;
inline bool NatDetectResponse::has_nat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NatDetectResponse::set_has_nat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NatDetectResponse::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NatDetectResponse::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 NatDetectResponse::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectResponse.nat_type)
  return nat_type_;
}
inline void NatDetectResponse::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectResponse.nat_type)
}

// optional int32 detect_port = 2;
inline bool NatDetectResponse::has_detect_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NatDetectResponse::set_has_detect_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NatDetectResponse::clear_has_detect_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NatDetectResponse::clear_detect_port() {
  detect_port_ = 0;
  clear_has_detect_port();
}
inline ::google::protobuf::int32 NatDetectResponse::detect_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectResponse.detect_port)
  return detect_port_;
}
inline void NatDetectResponse::set_detect_port(::google::protobuf::int32 value) {
  set_has_detect_port();
  detect_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectResponse.detect_port)
}

// -------------------------------------------------------------------

// NatDetectFinish

// optional int32 resv = 1;
inline bool NatDetectFinish::has_resv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NatDetectFinish::set_has_resv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NatDetectFinish::clear_has_resv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NatDetectFinish::clear_resv() {
  resv_ = 0;
  clear_has_resv();
}
inline ::google::protobuf::int32 NatDetectFinish::resv() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectFinish.resv)
  return resv_;
}
inline void NatDetectFinish::set_resv(::google::protobuf::int32 value) {
  set_has_resv();
  resv_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectFinish.resv)
}

// -------------------------------------------------------------------

// NatDetectHandshake2Node

// optional int32 resv = 1;
inline bool NatDetectHandshake2Node::has_resv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NatDetectHandshake2Node::set_has_resv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NatDetectHandshake2Node::clear_has_resv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NatDetectHandshake2Node::clear_resv() {
  resv_ = 0;
  clear_has_resv();
}
inline ::google::protobuf::int32 NatDetectHandshake2Node::resv() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectHandshake2Node.resv)
  return resv_;
}
inline void NatDetectHandshake2Node::set_resv(::google::protobuf::int32 value) {
  set_has_resv();
  resv_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectHandshake2Node.resv)
}

// -------------------------------------------------------------------

// NatDetectHandshake2Boot

// optional int32 resv = 1;
inline bool NatDetectHandshake2Boot::has_resv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NatDetectHandshake2Boot::set_has_resv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NatDetectHandshake2Boot::clear_has_resv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NatDetectHandshake2Boot::clear_resv() {
  resv_ = 0;
  clear_has_resv();
}
inline ::google::protobuf::int32 NatDetectHandshake2Boot::resv() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NatDetectHandshake2Boot.resv)
  return resv_;
}
inline void NatDetectHandshake2Boot::set_resv(::google::protobuf::int32 value) {
  set_has_resv();
  resv_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NatDetectHandshake2Boot.resv)
}

// -------------------------------------------------------------------

// Handshake

// optional bytes local_ip = 1;
inline bool Handshake::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Handshake::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Handshake::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Handshake::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& Handshake::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.local_ip)
  return local_ip_.GetNoArena();
}
inline void Handshake::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.local_ip)
}
#if LANG_CXX11
inline void Handshake::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.Handshake.local_ip)
}
#endif
inline void Handshake::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.Handshake.local_ip)
}
inline void Handshake::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.Handshake.local_ip)
}
inline ::std::string* Handshake::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.Handshake.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.Handshake.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handshake::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.Handshake.local_ip)
}

// optional int32 local_port = 2;
inline bool Handshake::has_local_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Handshake::set_has_local_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Handshake::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Handshake::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 Handshake::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.local_port)
  return local_port_;
}
inline void Handshake::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.local_port)
}

// optional int32 type = 3;
inline bool Handshake::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Handshake::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Handshake::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Handshake::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Handshake::type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.type)
  return type_;
}
inline void Handshake::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.type)
}

// optional bytes public_ip = 4;
inline bool Handshake::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Handshake::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Handshake::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Handshake::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& Handshake::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.public_ip)
  return public_ip_.GetNoArena();
}
inline void Handshake::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.public_ip)
}
#if LANG_CXX11
inline void Handshake::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.Handshake.public_ip)
}
#endif
inline void Handshake::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.Handshake.public_ip)
}
inline void Handshake::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.Handshake.public_ip)
}
inline ::std::string* Handshake::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.Handshake.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.Handshake.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handshake::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.Handshake.public_ip)
}

// optional int32 public_port = 5;
inline bool Handshake::has_public_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Handshake::set_has_public_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Handshake::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Handshake::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 Handshake::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.public_port)
  return public_port_;
}
inline void Handshake::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.public_port)
}

// optional int32 nat_type = 6;
inline bool Handshake::has_nat_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Handshake::set_has_nat_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Handshake::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Handshake::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 Handshake::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.nat_type)
  return nat_type_;
}
inline void Handshake::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.nat_type)
}

// optional bytes xid = 7;
inline bool Handshake::has_xid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Handshake::set_has_xid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Handshake::clear_has_xid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Handshake::clear_xid() {
  xid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xid();
}
inline const ::std::string& Handshake::xid() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.xid)
  return xid_.GetNoArena();
}
inline void Handshake::set_xid(const ::std::string& value) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.xid)
}
#if LANG_CXX11
inline void Handshake::set_xid(::std::string&& value) {
  set_has_xid();
  xid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.Handshake.xid)
}
#endif
inline void Handshake::set_xid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.Handshake.xid)
}
inline void Handshake::set_xid(const void* value, size_t size) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.Handshake.xid)
}
inline ::std::string* Handshake::mutable_xid() {
  set_has_xid();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.Handshake.xid)
  return xid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_xid() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.Handshake.xid)
  if (!has_xid()) {
    return NULL;
  }
  clear_has_xid();
  return xid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handshake::set_allocated_xid(::std::string* xid) {
  if (xid != NULL) {
    set_has_xid();
  } else {
    clear_has_xid();
  }
  xid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xid);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.Handshake.xid)
}

// optional bytes xip = 8;
inline bool Handshake::has_xip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Handshake::set_has_xip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Handshake::clear_has_xip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Handshake::clear_xip() {
  xip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xip();
}
inline const ::std::string& Handshake::xip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.Handshake.xip)
  return xip_.GetNoArena();
}
inline void Handshake::set_xip(const ::std::string& value) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.Handshake.xip)
}
#if LANG_CXX11
inline void Handshake::set_xip(::std::string&& value) {
  set_has_xip();
  xip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.Handshake.xip)
}
#endif
inline void Handshake::set_xip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.Handshake.xip)
}
inline void Handshake::set_xip(const void* value, size_t size) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.Handshake.xip)
}
inline ::std::string* Handshake::mutable_xip() {
  set_has_xip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.Handshake.xip)
  return xip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Handshake::release_xip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.Handshake.xip)
  if (!has_xip()) {
    return NULL;
  }
  clear_has_xip();
  return xip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Handshake::set_allocated_xip(::std::string* xip) {
  if (xip != NULL) {
    set_has_xip();
  } else {
    clear_has_xip();
  }
  xip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.Handshake.xip)
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes public_ip = 1;
inline bool NodeInfo::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& NodeInfo::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.public_ip)
  return public_ip_.GetNoArena();
}
inline void NodeInfo::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.public_ip)
}
#if LANG_CXX11
inline void NodeInfo::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NodeInfo.public_ip)
}
#endif
inline void NodeInfo::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NodeInfo.public_ip)
}
inline void NodeInfo::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NodeInfo.public_ip)
}
inline ::std::string* NodeInfo::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NodeInfo.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NodeInfo.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NodeInfo.public_ip)
}

// optional int32 public_port = 2;
inline bool NodeInfo::has_public_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeInfo::set_has_public_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeInfo::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeInfo::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 NodeInfo::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.public_port)
  return public_port_;
}
inline void NodeInfo::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.public_port)
}

// optional bytes local_ip = 3;
inline bool NodeInfo::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& NodeInfo::local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.local_ip)
  return local_ip_.GetNoArena();
}
inline void NodeInfo::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.local_ip)
}
#if LANG_CXX11
inline void NodeInfo::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NodeInfo.local_ip)
}
#endif
inline void NodeInfo::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NodeInfo.local_ip)
}
inline void NodeInfo::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NodeInfo.local_ip)
}
inline ::std::string* NodeInfo::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NodeInfo.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NodeInfo.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NodeInfo.local_ip)
}

// optional int32 local_port = 4;
inline bool NodeInfo::has_local_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeInfo::set_has_local_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeInfo::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeInfo::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 NodeInfo::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.local_port)
  return local_port_;
}
inline void NodeInfo::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.local_port)
}

// optional bytes id = 5;
inline bool NodeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& NodeInfo::id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.id)
  return id_.GetNoArena();
}
inline void NodeInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.id)
}
#if LANG_CXX11
inline void NodeInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NodeInfo.id)
}
#endif
inline void NodeInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NodeInfo.id)
}
inline void NodeInfo::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NodeInfo.id)
}
inline ::std::string* NodeInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NodeInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NodeInfo.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NodeInfo.id)
}

// optional int32 nat_type = 6;
inline bool NodeInfo::has_nat_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeInfo::set_has_nat_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeInfo::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeInfo::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 NodeInfo::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.nat_type)
  return nat_type_;
}
inline void NodeInfo::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.nat_type)
}

// optional bytes xip = 7;
inline bool NodeInfo::has_xip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeInfo::set_has_xip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeInfo::clear_has_xip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeInfo::clear_xip() {
  xip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xip();
}
inline const ::std::string& NodeInfo::xip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.xip)
  return xip_.GetNoArena();
}
inline void NodeInfo::set_xip(const ::std::string& value) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.xip)
}
#if LANG_CXX11
inline void NodeInfo::set_xip(::std::string&& value) {
  set_has_xip();
  xip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NodeInfo.xip)
}
#endif
inline void NodeInfo::set_xip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NodeInfo.xip)
}
inline void NodeInfo::set_xip(const void* value, size_t size) {
  set_has_xip();
  xip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NodeInfo.xip)
}
inline ::std::string* NodeInfo::mutable_xip() {
  set_has_xip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NodeInfo.xip)
  return xip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_xip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NodeInfo.xip)
  if (!has_xip()) {
    return NULL;
  }
  clear_has_xip();
  return xip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_xip(::std::string* xip) {
  if (xip != NULL) {
    set_has_xip();
  } else {
    clear_has_xip();
  }
  xip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NodeInfo.xip)
}

// optional bytes xid = 8;
inline bool NodeInfo::has_xid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeInfo::set_has_xid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeInfo::clear_has_xid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeInfo::clear_xid() {
  xid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xid();
}
inline const ::std::string& NodeInfo::xid() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.NodeInfo.xid)
  return xid_.GetNoArena();
}
inline void NodeInfo::set_xid(const ::std::string& value) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.NodeInfo.xid)
}
#if LANG_CXX11
inline void NodeInfo::set_xid(::std::string&& value) {
  set_has_xid();
  xid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.NodeInfo.xid)
}
#endif
inline void NodeInfo::set_xid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.NodeInfo.xid)
}
inline void NodeInfo::set_xid(const void* value, size_t size) {
  set_has_xid();
  xid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.NodeInfo.xid)
}
inline ::std::string* NodeInfo::mutable_xid() {
  set_has_xid();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.NodeInfo.xid)
  return xid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_xid() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.NodeInfo.xid)
  if (!has_xid()) {
    return NULL;
  }
  clear_has_xid();
  return xid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_xid(::std::string* xid) {
  if (xid != NULL) {
    set_has_xid();
  } else {
    clear_has_xid();
  }
  xid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xid);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.NodeInfo.xid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Heartbeat

// map<string, string> extinfo_map = 1;
inline int Heartbeat::extinfo_map_size() const {
  return extinfo_map_.size();
}
inline void Heartbeat::clear_extinfo_map() {
  extinfo_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Heartbeat::extinfo_map() const {
  // @@protoc_insertion_point(field_map:top.kadmlia.protobuf.Heartbeat.extinfo_map)
  return extinfo_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Heartbeat::mutable_extinfo_map() {
  // @@protoc_insertion_point(field_mutable_map:top.kadmlia.protobuf.Heartbeat.extinfo_map)
  return extinfo_map_.MutableMap();
}

// -------------------------------------------------------------------

// FindClosestNodesRequest

// optional uint32 count = 1;
inline bool FindClosestNodesRequest::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindClosestNodesRequest::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindClosestNodesRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindClosestNodesRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 FindClosestNodesRequest::count() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.FindClosestNodesRequest.count)
  return count_;
}
inline void FindClosestNodesRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.FindClosestNodesRequest.count)
}

// optional bytes target_id = 2;
inline bool FindClosestNodesRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindClosestNodesRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindClosestNodesRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindClosestNodesRequest::clear_target_id() {
  target_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_id();
}
inline const ::std::string& FindClosestNodesRequest::target_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
  return target_id_.GetNoArena();
}
inline void FindClosestNodesRequest::set_target_id(const ::std::string& value) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
}
#if LANG_CXX11
inline void FindClosestNodesRequest::set_target_id(::std::string&& value) {
  set_has_target_id();
  target_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
}
#endif
inline void FindClosestNodesRequest::set_target_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
}
inline void FindClosestNodesRequest::set_target_id(const void* value, size_t size) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
}
inline ::std::string* FindClosestNodesRequest::mutable_target_id() {
  set_has_target_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
  return target_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FindClosestNodesRequest::release_target_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
  if (!has_target_id()) {
    return NULL;
  }
  clear_has_target_id();
  return target_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindClosestNodesRequest::set_allocated_target_id(::std::string* target_id) {
  if (target_id != NULL) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  target_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.FindClosestNodesRequest.target_id)
}

// repeated uint64 bloomfilter = 3;
inline int FindClosestNodesRequest::bloomfilter_size() const {
  return bloomfilter_.size();
}
inline void FindClosestNodesRequest::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline ::google::protobuf::uint64 FindClosestNodesRequest::bloomfilter(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.FindClosestNodesRequest.bloomfilter)
  return bloomfilter_.Get(index);
}
inline void FindClosestNodesRequest::set_bloomfilter(int index, ::google::protobuf::uint64 value) {
  bloomfilter_.Set(index, value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.FindClosestNodesRequest.bloomfilter)
}
inline void FindClosestNodesRequest::add_bloomfilter(::google::protobuf::uint64 value) {
  bloomfilter_.Add(value);
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.FindClosestNodesRequest.bloomfilter)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
FindClosestNodesRequest::bloomfilter() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.FindClosestNodesRequest.bloomfilter)
  return bloomfilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
FindClosestNodesRequest::mutable_bloomfilter() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.FindClosestNodesRequest.bloomfilter)
  return &bloomfilter_;
}

// optional .top.kadmlia.protobuf.NodeInfo src_nodeinfo = 4;
inline bool FindClosestNodesRequest::has_src_nodeinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindClosestNodesRequest::set_has_src_nodeinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindClosestNodesRequest::clear_has_src_nodeinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindClosestNodesRequest::clear_src_nodeinfo() {
  if (src_nodeinfo_ != NULL) src_nodeinfo_->Clear();
  clear_has_src_nodeinfo();
}
inline const ::top::kadmlia::protobuf::NodeInfo& FindClosestNodesRequest::_internal_src_nodeinfo() const {
  return *src_nodeinfo_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& FindClosestNodesRequest::src_nodeinfo() const {
  const ::top::kadmlia::protobuf::NodeInfo* p = src_nodeinfo_;
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.FindClosestNodesRequest.src_nodeinfo)
  return p != NULL ? *p : *reinterpret_cast<const ::top::kadmlia::protobuf::NodeInfo*>(
      &::top::kadmlia::protobuf::_NodeInfo_default_instance_);
}
inline ::top::kadmlia::protobuf::NodeInfo* FindClosestNodesRequest::release_src_nodeinfo() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.FindClosestNodesRequest.src_nodeinfo)
  clear_has_src_nodeinfo();
  ::top::kadmlia::protobuf::NodeInfo* temp = src_nodeinfo_;
  src_nodeinfo_ = NULL;
  return temp;
}
inline ::top::kadmlia::protobuf::NodeInfo* FindClosestNodesRequest::mutable_src_nodeinfo() {
  set_has_src_nodeinfo();
  if (src_nodeinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::top::kadmlia::protobuf::NodeInfo>(GetArenaNoVirtual());
    src_nodeinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.FindClosestNodesRequest.src_nodeinfo)
  return src_nodeinfo_;
}
inline void FindClosestNodesRequest::set_allocated_src_nodeinfo(::top::kadmlia::protobuf::NodeInfo* src_nodeinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete src_nodeinfo_;
  }
  if (src_nodeinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      src_nodeinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_nodeinfo, submessage_arena);
    }
    set_has_src_nodeinfo();
  } else {
    clear_has_src_nodeinfo();
  }
  src_nodeinfo_ = src_nodeinfo;
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.FindClosestNodesRequest.src_nodeinfo)
}

// -------------------------------------------------------------------

// FindClosestNodesResponse

// repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
inline int FindClosestNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void FindClosestNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::protobuf::NodeInfo* FindClosestNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.FindClosestNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
FindClosestNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.FindClosestNodesResponse.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& FindClosestNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.FindClosestNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::protobuf::NodeInfo* FindClosestNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.FindClosestNodesResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
FindClosestNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.FindClosestNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetNearestNodesRequest

// optional bytes target_id = 1;
inline bool GetNearestNodesRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNearestNodesRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNearestNodesRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNearestNodesRequest::clear_target_id() {
  target_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_id();
}
inline const ::std::string& GetNearestNodesRequest::target_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
  return target_id_.GetNoArena();
}
inline void GetNearestNodesRequest::set_target_id(const ::std::string& value) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
}
#if LANG_CXX11
inline void GetNearestNodesRequest::set_target_id(::std::string&& value) {
  set_has_target_id();
  target_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
}
#endif
inline void GetNearestNodesRequest::set_target_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
}
inline void GetNearestNodesRequest::set_target_id(const void* value, size_t size) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
}
inline ::std::string* GetNearestNodesRequest::mutable_target_id() {
  set_has_target_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
  return target_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNearestNodesRequest::release_target_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
  if (!has_target_id()) {
    return NULL;
  }
  clear_has_target_id();
  return target_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNearestNodesRequest::set_allocated_target_id(::std::string* target_id) {
  if (target_id != NULL) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  target_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.GetNearestNodesRequest.target_id)
}

// optional uint32 count = 2;
inline bool GetNearestNodesRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNearestNodesRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNearestNodesRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNearestNodesRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetNearestNodesRequest::count() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetNearestNodesRequest.count)
  return count_;
}
inline void GetNearestNodesRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.GetNearestNodesRequest.count)
}

// -------------------------------------------------------------------

// GetNearestNodesResponse

// repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
inline int GetNearestNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetNearestNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::protobuf::NodeInfo* GetNearestNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.GetNearestNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
GetNearestNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.GetNearestNodesResponse.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& GetNearestNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetNearestNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::protobuf::NodeInfo* GetNearestNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.GetNearestNodesResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
GetNearestNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.GetNearestNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// UdpNatDetectRequest

// optional uint32 resv = 1;
inline bool UdpNatDetectRequest::has_resv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpNatDetectRequest::set_has_resv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpNatDetectRequest::clear_has_resv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpNatDetectRequest::clear_resv() {
  resv_ = 0u;
  clear_has_resv();
}
inline ::google::protobuf::uint32 UdpNatDetectRequest::resv() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.UdpNatDetectRequest.resv)
  return resv_;
}
inline void UdpNatDetectRequest::set_resv(::google::protobuf::uint32 value) {
  set_has_resv();
  resv_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.UdpNatDetectRequest.resv)
}

// -------------------------------------------------------------------

// UdpNatDetectResponse

// optional bytes public_ip = 1;
inline bool UdpNatDetectResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpNatDetectResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpNatDetectResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpNatDetectResponse::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& UdpNatDetectResponse::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
  return public_ip_.GetNoArena();
}
inline void UdpNatDetectResponse::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
}
#if LANG_CXX11
inline void UdpNatDetectResponse::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
}
#endif
inline void UdpNatDetectResponse::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
}
inline void UdpNatDetectResponse::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
}
inline ::std::string* UdpNatDetectResponse::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UdpNatDetectResponse::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UdpNatDetectResponse::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.UdpNatDetectResponse.public_ip)
}

// optional int32 public_port = 2;
inline bool UdpNatDetectResponse::has_public_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpNatDetectResponse::set_has_public_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpNatDetectResponse::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpNatDetectResponse::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 UdpNatDetectResponse::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.UdpNatDetectResponse.public_port)
  return public_port_;
}
inline void UdpNatDetectResponse::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.UdpNatDetectResponse.public_port)
}

// -------------------------------------------------------------------

// EdgeNodesRequest

// optional bytes target_id = 1;
inline bool EdgeNodesRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeNodesRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeNodesRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeNodesRequest::clear_target_id() {
  target_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_id();
}
inline const ::std::string& EdgeNodesRequest::target_id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
  return target_id_.GetNoArena();
}
inline void EdgeNodesRequest::set_target_id(const ::std::string& value) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
}
#if LANG_CXX11
inline void EdgeNodesRequest::set_target_id(::std::string&& value) {
  set_has_target_id();
  target_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
}
#endif
inline void EdgeNodesRequest::set_target_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
}
inline void EdgeNodesRequest::set_target_id(const void* value, size_t size) {
  set_has_target_id();
  target_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
}
inline ::std::string* EdgeNodesRequest::mutable_target_id() {
  set_has_target_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
  return target_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EdgeNodesRequest::release_target_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
  if (!has_target_id()) {
    return NULL;
  }
  clear_has_target_id();
  return target_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EdgeNodesRequest::set_allocated_target_id(::std::string* target_id) {
  if (target_id != NULL) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  target_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.EdgeNodesRequest.target_id)
}

// optional uint32 count = 2;
inline bool EdgeNodesRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeNodesRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeNodesRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeNodesRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 EdgeNodesRequest::count() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.EdgeNodesRequest.count)
  return count_;
}
inline void EdgeNodesRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.EdgeNodesRequest.count)
}

// -------------------------------------------------------------------

// EdgeNodesResponse

// repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
inline int EdgeNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void EdgeNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::protobuf::NodeInfo* EdgeNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.EdgeNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
EdgeNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.EdgeNodesResponse.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& EdgeNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.EdgeNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::protobuf::NodeInfo* EdgeNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.EdgeNodesResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
EdgeNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.EdgeNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// AddressInfo

// optional bytes public_ip = 1;
inline bool AddressInfo::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddressInfo::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddressInfo::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddressInfo::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& AddressInfo::public_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.AddressInfo.public_ip)
  return public_ip_.GetNoArena();
}
inline void AddressInfo::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.AddressInfo.public_ip)
}
#if LANG_CXX11
inline void AddressInfo::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.AddressInfo.public_ip)
}
#endif
inline void AddressInfo::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.AddressInfo.public_ip)
}
inline void AddressInfo::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.AddressInfo.public_ip)
}
inline ::std::string* AddressInfo::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.AddressInfo.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddressInfo::release_public_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.AddressInfo.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddressInfo::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.AddressInfo.public_ip)
}

// optional uint32 public_port = 2;
inline bool AddressInfo::has_public_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddressInfo::set_has_public_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddressInfo::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddressInfo::clear_public_port() {
  public_port_ = 0u;
  clear_has_public_port();
}
inline ::google::protobuf::uint32 AddressInfo::public_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.AddressInfo.public_port)
  return public_port_;
}
inline void AddressInfo::set_public_port(::google::protobuf::uint32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.AddressInfo.public_port)
}

// optional uint32 local_port = 3;
inline bool AddressInfo::has_local_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddressInfo::set_has_local_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddressInfo::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddressInfo::clear_local_port() {
  local_port_ = 0u;
  clear_has_local_port();
}
inline ::google::protobuf::uint32 AddressInfo::local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.AddressInfo.local_port)
  return local_port_;
}
inline void AddressInfo::set_local_port(::google::protobuf::uint32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.AddressInfo.local_port)
}

// optional bytes detect_local_ip = 4;
inline bool AddressInfo::has_detect_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddressInfo::set_has_detect_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddressInfo::clear_has_detect_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddressInfo::clear_detect_local_ip() {
  detect_local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detect_local_ip();
}
inline const ::std::string& AddressInfo::detect_local_ip() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
  return detect_local_ip_.GetNoArena();
}
inline void AddressInfo::set_detect_local_ip(const ::std::string& value) {
  set_has_detect_local_ip();
  detect_local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
}
#if LANG_CXX11
inline void AddressInfo::set_detect_local_ip(::std::string&& value) {
  set_has_detect_local_ip();
  detect_local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
}
#endif
inline void AddressInfo::set_detect_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detect_local_ip();
  detect_local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
}
inline void AddressInfo::set_detect_local_ip(const void* value, size_t size) {
  set_has_detect_local_ip();
  detect_local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
}
inline ::std::string* AddressInfo::mutable_detect_local_ip() {
  set_has_detect_local_ip();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
  return detect_local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddressInfo::release_detect_local_ip() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
  if (!has_detect_local_ip()) {
    return NULL;
  }
  clear_has_detect_local_ip();
  return detect_local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddressInfo::set_allocated_detect_local_ip(::std::string* detect_local_ip) {
  if (detect_local_ip != NULL) {
    set_has_detect_local_ip();
  } else {
    clear_has_detect_local_ip();
  }
  detect_local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detect_local_ip);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.AddressInfo.detect_local_ip)
}

// optional uint32 detect_local_port = 5;
inline bool AddressInfo::has_detect_local_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddressInfo::set_has_detect_local_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddressInfo::clear_has_detect_local_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddressInfo::clear_detect_local_port() {
  detect_local_port_ = 0u;
  clear_has_detect_local_port();
}
inline ::google::protobuf::uint32 AddressInfo::detect_local_port() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.AddressInfo.detect_local_port)
  return detect_local_port_;
}
inline void AddressInfo::set_detect_local_port(::google::protobuf::uint32 value) {
  set_has_detect_local_port();
  detect_local_port_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.AddressInfo.detect_local_port)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EdgeInfoRequest

// map<uint32, .top.kadmlia.protobuf.AddressInfo> client_info = 1;
inline int EdgeInfoRequest::client_info_size() const {
  return client_info_.size();
}
inline void EdgeInfoRequest::clear_client_info() {
  client_info_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >&
EdgeInfoRequest::client_info() const {
  // @@protoc_insertion_point(field_map:top.kadmlia.protobuf.EdgeInfoRequest.client_info)
  return client_info_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >*
EdgeInfoRequest::mutable_client_info() {
  // @@protoc_insertion_point(field_mutable_map:top.kadmlia.protobuf.EdgeInfoRequest.client_info)
  return client_info_.MutableMap();
}

// optional int32 nat_type = 2;
inline bool EdgeInfoRequest::has_nat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeInfoRequest::set_has_nat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeInfoRequest::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeInfoRequest::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 EdgeInfoRequest::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.EdgeInfoRequest.nat_type)
  return nat_type_;
}
inline void EdgeInfoRequest::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.EdgeInfoRequest.nat_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EdgeInfoResponse

// map<uint32, .top.kadmlia.protobuf.AddressInfo> edge_info = 1;
inline int EdgeInfoResponse::edge_info_size() const {
  return edge_info_.size();
}
inline void EdgeInfoResponse::clear_edge_info() {
  edge_info_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >&
EdgeInfoResponse::edge_info() const {
  // @@protoc_insertion_point(field_map:top.kadmlia.protobuf.EdgeInfoResponse.edge_info)
  return edge_info_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::top::kadmlia::protobuf::AddressInfo >*
EdgeInfoResponse::mutable_edge_info() {
  // @@protoc_insertion_point(field_mutable_map:top.kadmlia.protobuf.EdgeInfoResponse.edge_info)
  return edge_info_.MutableMap();
}

// optional int32 nat_type = 2;
inline bool EdgeInfoResponse::has_nat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeInfoResponse::set_has_nat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeInfoResponse::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeInfoResponse::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 EdgeInfoResponse::nat_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.EdgeInfoResponse.nat_type)
  return nat_type_;
}
inline void EdgeInfoResponse::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.EdgeInfoResponse.nat_type)
}

// -------------------------------------------------------------------

// GetAllNodesFromBootRequest

// optional int32 start_pos = 1;
inline bool GetAllNodesFromBootRequest::has_start_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllNodesFromBootRequest::set_has_start_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllNodesFromBootRequest::clear_has_start_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllNodesFromBootRequest::clear_start_pos() {
  start_pos_ = 0;
  clear_has_start_pos();
}
inline ::google::protobuf::int32 GetAllNodesFromBootRequest::start_pos() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetAllNodesFromBootRequest.start_pos)
  return start_pos_;
}
inline void GetAllNodesFromBootRequest::set_start_pos(::google::protobuf::int32 value) {
  set_has_start_pos();
  start_pos_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.GetAllNodesFromBootRequest.start_pos)
}

// optional int32 len = 2;
inline bool GetAllNodesFromBootRequest::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAllNodesFromBootRequest::set_has_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAllNodesFromBootRequest::clear_has_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAllNodesFromBootRequest::clear_len() {
  len_ = 0;
  clear_has_len();
}
inline ::google::protobuf::int32 GetAllNodesFromBootRequest::len() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetAllNodesFromBootRequest.len)
  return len_;
}
inline void GetAllNodesFromBootRequest::set_len(::google::protobuf::int32 value) {
  set_has_len();
  len_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.GetAllNodesFromBootRequest.len)
}

// -------------------------------------------------------------------

// GetAllNodesFromBootResponse

// repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
inline int GetAllNodesFromBootResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetAllNodesFromBootResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::protobuf::NodeInfo* GetAllNodesFromBootResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.GetAllNodesFromBootResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
GetAllNodesFromBootResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.GetAllNodesFromBootResponse.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& GetAllNodesFromBootResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.GetAllNodesFromBootResponse.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::protobuf::NodeInfo* GetAllNodesFromBootResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.GetAllNodesFromBootResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
GetAllNodesFromBootResponse::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.GetAllNodesFromBootResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// SmartObjectData

// optional uint32 type = 1;
inline bool SmartObjectData::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SmartObjectData::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SmartObjectData::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SmartObjectData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SmartObjectData::type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.type)
  return type_;
}
inline void SmartObjectData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.type)
}

// optional uint32 oper = 2;
inline bool SmartObjectData::has_oper() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SmartObjectData::set_has_oper() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SmartObjectData::clear_has_oper() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SmartObjectData::clear_oper() {
  oper_ = 0u;
  clear_has_oper();
}
inline ::google::protobuf::uint32 SmartObjectData::oper() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.oper)
  return oper_;
}
inline void SmartObjectData::set_oper(::google::protobuf::uint32 value) {
  set_has_oper();
  oper_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.oper)
}

// optional bytes key = 3;
inline bool SmartObjectData::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartObjectData::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartObjectData::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartObjectData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SmartObjectData::key() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.key)
  return key_.GetNoArena();
}
inline void SmartObjectData::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.key)
}
#if LANG_CXX11
inline void SmartObjectData::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectData.key)
}
#endif
inline void SmartObjectData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.key)
}
inline void SmartObjectData::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.key)
}
inline ::std::string* SmartObjectData::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectData::release_key() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectData.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectData.key)
}

// optional bytes value = 4;
inline bool SmartObjectData::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmartObjectData::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmartObjectData::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmartObjectData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& SmartObjectData::value() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.value)
  return value_.GetNoArena();
}
inline void SmartObjectData::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.value)
}
#if LANG_CXX11
inline void SmartObjectData::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectData.value)
}
#endif
inline void SmartObjectData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.value)
}
inline void SmartObjectData::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.value)
}
inline ::std::string* SmartObjectData::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectData::release_value() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectData.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectData.value)
}

// optional bytes field = 5;
inline bool SmartObjectData::has_field() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmartObjectData::set_has_field() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmartObjectData::clear_has_field() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmartObjectData::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field();
}
inline const ::std::string& SmartObjectData::field() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.field)
  return field_.GetNoArena();
}
inline void SmartObjectData::set_field(const ::std::string& value) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.field)
}
#if LANG_CXX11
inline void SmartObjectData::set_field(::std::string&& value) {
  set_has_field();
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectData.field)
}
#endif
inline void SmartObjectData::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.field)
}
inline void SmartObjectData::set_field(const void* value, size_t size) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.field)
}
inline ::std::string* SmartObjectData::mutable_field() {
  set_has_field();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectData::release_field() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectData.field)
  if (!has_field()) {
    return NULL;
  }
  clear_has_field();
  return field_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectData::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    set_has_field();
  } else {
    clear_has_field();
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectData.field)
}

// repeated bytes list_value = 6;
inline int SmartObjectData::list_value_size() const {
  return list_value_.size();
}
inline void SmartObjectData::clear_list_value() {
  list_value_.Clear();
}
inline const ::std::string& SmartObjectData::list_value(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.list_value)
  return list_value_.Get(index);
}
inline ::std::string* SmartObjectData::mutable_list_value(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.list_value)
  return list_value_.Mutable(index);
}
inline void SmartObjectData::set_list_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.list_value)
  list_value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SmartObjectData::set_list_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.list_value)
  list_value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SmartObjectData::set_list_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  list_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.list_value)
}
inline void SmartObjectData::set_list_value(int index, const void* value, size_t size) {
  list_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.list_value)
}
inline ::std::string* SmartObjectData::add_list_value() {
  // @@protoc_insertion_point(field_add_mutable:top.kadmlia.protobuf.SmartObjectData.list_value)
  return list_value_.Add();
}
inline void SmartObjectData::add_list_value(const ::std::string& value) {
  list_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectData.list_value)
}
#if LANG_CXX11
inline void SmartObjectData::add_list_value(::std::string&& value) {
  list_value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectData.list_value)
}
#endif
inline void SmartObjectData::add_list_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  list_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:top.kadmlia.protobuf.SmartObjectData.list_value)
}
inline void SmartObjectData::add_list_value(const void* value, size_t size) {
  list_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:top.kadmlia.protobuf.SmartObjectData.list_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmartObjectData::list_value() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.SmartObjectData.list_value)
  return list_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmartObjectData::mutable_list_value() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.SmartObjectData.list_value)
  return &list_value_;
}

// optional uint32 ttl = 7;
inline bool SmartObjectData::has_ttl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SmartObjectData::set_has_ttl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SmartObjectData::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SmartObjectData::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 SmartObjectData::ttl() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.ttl)
  return ttl_;
}
inline void SmartObjectData::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.ttl)
}

// optional bytes public_key = 8;
inline bool SmartObjectData::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SmartObjectData::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SmartObjectData::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SmartObjectData::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& SmartObjectData::public_key() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.public_key)
  return public_key_.GetNoArena();
}
inline void SmartObjectData::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.public_key)
}
#if LANG_CXX11
inline void SmartObjectData::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectData.public_key)
}
#endif
inline void SmartObjectData::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.public_key)
}
inline void SmartObjectData::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.public_key)
}
inline ::std::string* SmartObjectData::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectData::release_public_key() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectData.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectData::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectData.public_key)
}

// optional bytes aes_key = 9;
inline bool SmartObjectData::has_aes_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SmartObjectData::set_has_aes_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SmartObjectData::clear_has_aes_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SmartObjectData::clear_aes_key() {
  aes_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_aes_key();
}
inline const ::std::string& SmartObjectData::aes_key() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.aes_key)
  return aes_key_.GetNoArena();
}
inline void SmartObjectData::set_aes_key(const ::std::string& value) {
  set_has_aes_key();
  aes_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.aes_key)
}
#if LANG_CXX11
inline void SmartObjectData::set_aes_key(::std::string&& value) {
  set_has_aes_key();
  aes_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectData.aes_key)
}
#endif
inline void SmartObjectData::set_aes_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_aes_key();
  aes_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectData.aes_key)
}
inline void SmartObjectData::set_aes_key(const void* value, size_t size) {
  set_has_aes_key();
  aes_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectData.aes_key)
}
inline ::std::string* SmartObjectData::mutable_aes_key() {
  set_has_aes_key();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectData.aes_key)
  return aes_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectData::release_aes_key() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectData.aes_key)
  if (!has_aes_key()) {
    return NULL;
  }
  clear_has_aes_key();
  return aes_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectData::set_allocated_aes_key(::std::string* aes_key) {
  if (aes_key != NULL) {
    set_has_aes_key();
  } else {
    clear_has_aes_key();
  }
  aes_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aes_key);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectData.aes_key)
}

// optional uint32 encrypt_mode = 10;
inline bool SmartObjectData::has_encrypt_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SmartObjectData::set_has_encrypt_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SmartObjectData::clear_has_encrypt_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SmartObjectData::clear_encrypt_mode() {
  encrypt_mode_ = 0u;
  clear_has_encrypt_mode();
}
inline ::google::protobuf::uint32 SmartObjectData::encrypt_mode() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectData.encrypt_mode)
  return encrypt_mode_;
}
inline void SmartObjectData::set_encrypt_mode(::google::protobuf::uint32 value) {
  set_has_encrypt_mode();
  encrypt_mode_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectData.encrypt_mode)
}

// -------------------------------------------------------------------

// SmartObjectTuple

// optional uint32 type = 1;
inline bool SmartObjectTuple::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SmartObjectTuple::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SmartObjectTuple::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SmartObjectTuple::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SmartObjectTuple::type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.type)
  return type_;
}
inline void SmartObjectTuple::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.type)
}

// optional bytes key = 2;
inline bool SmartObjectTuple::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartObjectTuple::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartObjectTuple::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartObjectTuple::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SmartObjectTuple::key() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.key)
  return key_.GetNoArena();
}
inline void SmartObjectTuple::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.key)
}
#if LANG_CXX11
inline void SmartObjectTuple::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectTuple.key)
}
#endif
inline void SmartObjectTuple::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectTuple.key)
}
inline void SmartObjectTuple::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectTuple.key)
}
inline ::std::string* SmartObjectTuple::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectTuple.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectTuple::release_key() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectTuple.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectTuple::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectTuple.key)
}

// optional bytes value = 3;
inline bool SmartObjectTuple::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmartObjectTuple::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmartObjectTuple::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmartObjectTuple::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& SmartObjectTuple::value() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.value)
  return value_.GetNoArena();
}
inline void SmartObjectTuple::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.value)
}
#if LANG_CXX11
inline void SmartObjectTuple::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectTuple.value)
}
#endif
inline void SmartObjectTuple::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectTuple.value)
}
inline void SmartObjectTuple::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectTuple.value)
}
inline ::std::string* SmartObjectTuple::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectTuple.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectTuple::release_value() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectTuple.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectTuple::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectTuple.value)
}

// optional bytes field = 4;
inline bool SmartObjectTuple::has_field() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmartObjectTuple::set_has_field() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmartObjectTuple::clear_has_field() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmartObjectTuple::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field();
}
inline const ::std::string& SmartObjectTuple::field() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.field)
  return field_.GetNoArena();
}
inline void SmartObjectTuple::set_field(const ::std::string& value) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.field)
}
#if LANG_CXX11
inline void SmartObjectTuple::set_field(::std::string&& value) {
  set_has_field();
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectTuple.field)
}
#endif
inline void SmartObjectTuple::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectTuple.field)
}
inline void SmartObjectTuple::set_field(const void* value, size_t size) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectTuple.field)
}
inline ::std::string* SmartObjectTuple::mutable_field() {
  set_has_field();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectTuple.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectTuple::release_field() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectTuple.field)
  if (!has_field()) {
    return NULL;
  }
  clear_has_field();
  return field_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectTuple::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    set_has_field();
  } else {
    clear_has_field();
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectTuple.field)
}

// repeated bytes list_value = 5;
inline int SmartObjectTuple::list_value_size() const {
  return list_value_.size();
}
inline void SmartObjectTuple::clear_list_value() {
  list_value_.Clear();
}
inline const ::std::string& SmartObjectTuple::list_value(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  return list_value_.Get(index);
}
inline ::std::string* SmartObjectTuple::mutable_list_value(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  return list_value_.Mutable(index);
}
inline void SmartObjectTuple::set_list_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  list_value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SmartObjectTuple::set_list_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  list_value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SmartObjectTuple::set_list_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  list_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
inline void SmartObjectTuple::set_list_value(int index, const void* value, size_t size) {
  list_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
inline ::std::string* SmartObjectTuple::add_list_value() {
  // @@protoc_insertion_point(field_add_mutable:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  return list_value_.Add();
}
inline void SmartObjectTuple::add_list_value(const ::std::string& value) {
  list_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
#if LANG_CXX11
inline void SmartObjectTuple::add_list_value(::std::string&& value) {
  list_value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
#endif
inline void SmartObjectTuple::add_list_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  list_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
inline void SmartObjectTuple::add_list_value(const void* value, size_t size) {
  list_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:top.kadmlia.protobuf.SmartObjectTuple.list_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SmartObjectTuple::list_value() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  return list_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SmartObjectTuple::mutable_list_value() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.SmartObjectTuple.list_value)
  return &list_value_;
}

// optional uint64 save_time = 6;
inline bool SmartObjectTuple::has_save_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SmartObjectTuple::set_has_save_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SmartObjectTuple::clear_has_save_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SmartObjectTuple::clear_save_time() {
  save_time_ = GOOGLE_ULONGLONG(0);
  clear_has_save_time();
}
inline ::google::protobuf::uint64 SmartObjectTuple::save_time() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.save_time)
  return save_time_;
}
inline void SmartObjectTuple::set_save_time(::google::protobuf::uint64 value) {
  set_has_save_time();
  save_time_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.save_time)
}

// optional uint32 ttl = 7;
inline bool SmartObjectTuple::has_ttl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SmartObjectTuple::set_has_ttl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SmartObjectTuple::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SmartObjectTuple::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 SmartObjectTuple::ttl() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectTuple.ttl)
  return ttl_;
}
inline void SmartObjectTuple::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectTuple.ttl)
}

// -------------------------------------------------------------------

// SmartObjectRefreshData

// optional uint32 oper = 1;
inline bool SmartObjectRefreshData::has_oper() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartObjectRefreshData::set_has_oper() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartObjectRefreshData::clear_has_oper() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartObjectRefreshData::clear_oper() {
  oper_ = 0u;
  clear_has_oper();
}
inline ::google::protobuf::uint32 SmartObjectRefreshData::oper() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectRefreshData.oper)
  return oper_;
}
inline void SmartObjectRefreshData::set_oper(::google::protobuf::uint32 value) {
  set_has_oper();
  oper_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectRefreshData.oper)
}

// repeated .top.kadmlia.protobuf.SmartObjectTuple list_tuple = 2;
inline int SmartObjectRefreshData::list_tuple_size() const {
  return list_tuple_.size();
}
inline void SmartObjectRefreshData::clear_list_tuple() {
  list_tuple_.Clear();
}
inline ::top::kadmlia::protobuf::SmartObjectTuple* SmartObjectRefreshData::mutable_list_tuple(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectRefreshData.list_tuple)
  return list_tuple_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectTuple >*
SmartObjectRefreshData::mutable_list_tuple() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.SmartObjectRefreshData.list_tuple)
  return &list_tuple_;
}
inline const ::top::kadmlia::protobuf::SmartObjectTuple& SmartObjectRefreshData::list_tuple(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectRefreshData.list_tuple)
  return list_tuple_.Get(index);
}
inline ::top::kadmlia::protobuf::SmartObjectTuple* SmartObjectRefreshData::add_list_tuple() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectRefreshData.list_tuple)
  return list_tuple_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectTuple >&
SmartObjectRefreshData::list_tuple() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.SmartObjectRefreshData.list_tuple)
  return list_tuple_;
}

// -------------------------------------------------------------------

// SmartObjectDataBlock

// optional uint32 id = 1;
inline bool SmartObjectDataBlock::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmartObjectDataBlock::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmartObjectDataBlock::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmartObjectDataBlock::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SmartObjectDataBlock::id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectDataBlock.id)
  return id_;
}
inline void SmartObjectDataBlock::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectDataBlock.id)
}

// optional bytes block_hash = 2;
inline bool SmartObjectDataBlock::has_block_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartObjectDataBlock::set_has_block_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartObjectDataBlock::clear_has_block_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartObjectDataBlock::clear_block_hash() {
  block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_block_hash();
}
inline const ::std::string& SmartObjectDataBlock::block_hash() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
  return block_hash_.GetNoArena();
}
inline void SmartObjectDataBlock::set_block_hash(const ::std::string& value) {
  set_has_block_hash();
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
}
#if LANG_CXX11
inline void SmartObjectDataBlock::set_block_hash(::std::string&& value) {
  set_has_block_hash();
  block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
}
#endif
inline void SmartObjectDataBlock::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_block_hash();
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
}
inline void SmartObjectDataBlock::set_block_hash(const void* value, size_t size) {
  set_has_block_hash();
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
}
inline ::std::string* SmartObjectDataBlock::mutable_block_hash() {
  set_has_block_hash();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
  return block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectDataBlock::release_block_hash() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
  if (!has_block_hash()) {
    return NULL;
  }
  clear_has_block_hash();
  return block_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectDataBlock::set_allocated_block_hash(::std::string* block_hash) {
  if (block_hash != NULL) {
    set_has_block_hash();
  } else {
    clear_has_block_hash();
  }
  block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_hash);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectDataBlock.block_hash)
}

// optional bytes data = 3;
inline bool SmartObjectDataBlock::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmartObjectDataBlock::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmartObjectDataBlock::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmartObjectDataBlock::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& SmartObjectDataBlock::data() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectDataBlock.data)
  return data_.GetNoArena();
}
inline void SmartObjectDataBlock::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectDataBlock.data)
}
#if LANG_CXX11
inline void SmartObjectDataBlock::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectDataBlock.data)
}
#endif
inline void SmartObjectDataBlock::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectDataBlock.data)
}
inline void SmartObjectDataBlock::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectDataBlock.data)
}
inline ::std::string* SmartObjectDataBlock::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectDataBlock.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectDataBlock::release_data() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectDataBlock.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectDataBlock::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectDataBlock.data)
}

// -------------------------------------------------------------------

// SmartObjectSyncData

// optional uint32 type = 1;
inline bool SmartObjectSyncData::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SmartObjectSyncData::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SmartObjectSyncData::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SmartObjectSyncData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SmartObjectSyncData::type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.type)
  return type_;
}
inline void SmartObjectSyncData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectSyncData.type)
}

// optional bytes key = 2;
inline bool SmartObjectSyncData::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartObjectSyncData::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartObjectSyncData::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartObjectSyncData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SmartObjectSyncData::key() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.key)
  return key_.GetNoArena();
}
inline void SmartObjectSyncData::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectSyncData.key)
}
#if LANG_CXX11
inline void SmartObjectSyncData::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectSyncData.key)
}
#endif
inline void SmartObjectSyncData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectSyncData.key)
}
inline void SmartObjectSyncData::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectSyncData.key)
}
inline ::std::string* SmartObjectSyncData::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectSyncData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectSyncData::release_key() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectSyncData.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectSyncData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectSyncData.key)
}

// optional bytes version = 3;
inline bool SmartObjectSyncData::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmartObjectSyncData::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmartObjectSyncData::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmartObjectSyncData::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& SmartObjectSyncData::version() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.version)
  return version_.GetNoArena();
}
inline void SmartObjectSyncData::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectSyncData.version)
}
#if LANG_CXX11
inline void SmartObjectSyncData::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectSyncData.version)
}
#endif
inline void SmartObjectSyncData::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectSyncData.version)
}
inline void SmartObjectSyncData::set_version(const void* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectSyncData.version)
}
inline ::std::string* SmartObjectSyncData::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectSyncData.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectSyncData::release_version() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectSyncData.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectSyncData::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectSyncData.version)
}

// optional bytes root_hash = 4;
inline bool SmartObjectSyncData::has_root_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmartObjectSyncData::set_has_root_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmartObjectSyncData::clear_has_root_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmartObjectSyncData::clear_root_hash() {
  root_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_root_hash();
}
inline const ::std::string& SmartObjectSyncData::root_hash() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
  return root_hash_.GetNoArena();
}
inline void SmartObjectSyncData::set_root_hash(const ::std::string& value) {
  set_has_root_hash();
  root_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
}
#if LANG_CXX11
inline void SmartObjectSyncData::set_root_hash(::std::string&& value) {
  set_has_root_hash();
  root_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
}
#endif
inline void SmartObjectSyncData::set_root_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_root_hash();
  root_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
}
inline void SmartObjectSyncData::set_root_hash(const void* value, size_t size) {
  set_has_root_hash();
  root_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
}
inline ::std::string* SmartObjectSyncData::mutable_root_hash() {
  set_has_root_hash();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
  return root_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectSyncData::release_root_hash() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
  if (!has_root_hash()) {
    return NULL;
  }
  clear_has_root_hash();
  return root_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectSyncData::set_allocated_root_hash(::std::string* root_hash) {
  if (root_hash != NULL) {
    set_has_root_hash();
  } else {
    clear_has_root_hash();
  }
  root_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root_hash);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectSyncData.root_hash)
}

// optional bytes sync_node = 5;
inline bool SmartObjectSyncData::has_sync_node() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SmartObjectSyncData::set_has_sync_node() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SmartObjectSyncData::clear_has_sync_node() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SmartObjectSyncData::clear_sync_node() {
  sync_node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sync_node();
}
inline const ::std::string& SmartObjectSyncData::sync_node() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
  return sync_node_.GetNoArena();
}
inline void SmartObjectSyncData::set_sync_node(const ::std::string& value) {
  set_has_sync_node();
  sync_node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
}
#if LANG_CXX11
inline void SmartObjectSyncData::set_sync_node(::std::string&& value) {
  set_has_sync_node();
  sync_node_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
}
#endif
inline void SmartObjectSyncData::set_sync_node(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sync_node();
  sync_node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
}
inline void SmartObjectSyncData::set_sync_node(const void* value, size_t size) {
  set_has_sync_node();
  sync_node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
}
inline ::std::string* SmartObjectSyncData::mutable_sync_node() {
  set_has_sync_node();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
  return sync_node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SmartObjectSyncData::release_sync_node() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
  if (!has_sync_node()) {
    return NULL;
  }
  clear_has_sync_node();
  return sync_node_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SmartObjectSyncData::set_allocated_sync_node(::std::string* sync_node) {
  if (sync_node != NULL) {
    set_has_sync_node();
  } else {
    clear_has_sync_node();
  }
  sync_node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sync_node);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.SmartObjectSyncData.sync_node)
}

// repeated .top.kadmlia.protobuf.SmartObjectDataBlock list_block = 6;
inline int SmartObjectSyncData::list_block_size() const {
  return list_block_.size();
}
inline void SmartObjectSyncData::clear_list_block() {
  list_block_.Clear();
}
inline ::top::kadmlia::protobuf::SmartObjectDataBlock* SmartObjectSyncData::mutable_list_block(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.SmartObjectSyncData.list_block)
  return list_block_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectDataBlock >*
SmartObjectSyncData::mutable_list_block() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.SmartObjectSyncData.list_block)
  return &list_block_;
}
inline const ::top::kadmlia::protobuf::SmartObjectDataBlock& SmartObjectSyncData::list_block(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.SmartObjectSyncData.list_block)
  return list_block_.Get(index);
}
inline ::top::kadmlia::protobuf::SmartObjectDataBlock* SmartObjectSyncData::add_list_block() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.SmartObjectSyncData.list_block)
  return list_block_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::SmartObjectDataBlock >&
SmartObjectSyncData::list_block() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.SmartObjectSyncData.list_block)
  return list_block_;
}

// -------------------------------------------------------------------

// RootGetNodesRequest

// optional bytes id = 1;
inline bool RootGetNodesRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RootGetNodesRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RootGetNodesRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RootGetNodesRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RootGetNodesRequest::id() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.RootGetNodesRequest.id)
  return id_.GetNoArena();
}
inline void RootGetNodesRequest::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.RootGetNodesRequest.id)
}
#if LANG_CXX11
inline void RootGetNodesRequest::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.RootGetNodesRequest.id)
}
#endif
inline void RootGetNodesRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.RootGetNodesRequest.id)
}
inline void RootGetNodesRequest::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.RootGetNodesRequest.id)
}
inline ::std::string* RootGetNodesRequest::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.RootGetNodesRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RootGetNodesRequest::release_id() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.RootGetNodesRequest.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RootGetNodesRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.RootGetNodesRequest.id)
}

// optional uint32 count = 2;
inline bool RootGetNodesRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RootGetNodesRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RootGetNodesRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RootGetNodesRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RootGetNodesRequest::count() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.RootGetNodesRequest.count)
  return count_;
}
inline void RootGetNodesRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.RootGetNodesRequest.count)
}

// -------------------------------------------------------------------

// RootGetNodesResponse

// repeated .top.kadmlia.protobuf.NodeInfo nodes = 1;
inline int RootGetNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void RootGetNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::top::kadmlia::protobuf::NodeInfo* RootGetNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.RootGetNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >*
RootGetNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:top.kadmlia.protobuf.RootGetNodesResponse.nodes)
  return &nodes_;
}
inline const ::top::kadmlia::protobuf::NodeInfo& RootGetNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.RootGetNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::top::kadmlia::protobuf::NodeInfo* RootGetNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:top.kadmlia.protobuf.RootGetNodesResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::top::kadmlia::protobuf::NodeInfo >&
RootGetNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:top.kadmlia.protobuf.RootGetNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// RootMessage

// optional uint32 message_type = 1;
inline bool RootMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RootMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RootMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RootMessage::clear_message_type() {
  message_type_ = 0u;
  clear_has_message_type();
}
inline ::google::protobuf::uint32 RootMessage::message_type() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.RootMessage.message_type)
  return message_type_;
}
inline void RootMessage::set_message_type(::google::protobuf::uint32 value) {
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.RootMessage.message_type)
}

// optional bytes data = 2;
inline bool RootMessage::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RootMessage::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RootMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RootMessage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& RootMessage::data() const {
  // @@protoc_insertion_point(field_get:top.kadmlia.protobuf.RootMessage.data)
  return data_.GetNoArena();
}
inline void RootMessage::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:top.kadmlia.protobuf.RootMessage.data)
}
#if LANG_CXX11
inline void RootMessage::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:top.kadmlia.protobuf.RootMessage.data)
}
#endif
inline void RootMessage::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:top.kadmlia.protobuf.RootMessage.data)
}
inline void RootMessage::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:top.kadmlia.protobuf.RootMessage.data)
}
inline ::std::string* RootMessage::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:top.kadmlia.protobuf.RootMessage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RootMessage::release_data() {
  // @@protoc_insertion_point(field_release:top.kadmlia.protobuf.RootMessage.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RootMessage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:top.kadmlia.protobuf.RootMessage.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace kadmlia
}  // namespace top

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_kadmlia_2eproto
